"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  require_jquery
} from "./chunk-SZ5TKG5R.js";
import {
  __commonJS,
  __toESM,
  require_dist
} from "./chunk-VKWKU3NF.js";

// node_modules/tablesorter/dist/js/jquery.tablesorter.combined.js
var require_jquery_tablesorter_combined = __commonJS({
  "node_modules/tablesorter/dist/js/jquery.tablesorter.combined.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    (function(factory) {
      if (typeof define === "function" && define.amd) {
        define(["jquery"], factory);
      } else if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory(require_jquery());
      } else {
        factory(jQuery);
      }
    })(function(jQuery2) {
      ;
      (function($) {
        "use strict";
        var ts = $.tablesorter = {
          version: "2.31.3",
          parsers: [],
          widgets: [],
          defaults: {
            // *** appearance
            theme: "default",
            // adds tablesorter-{theme} to the table for styling
            widthFixed: false,
            // adds colgroup to fix widths of columns
            showProcessing: false,
            // show an indeterminate timer icon in the header when the table is sorted or filtered.
            headerTemplate: "{content}",
            // header layout template (HTML ok); {content} = innerHTML, {icon} = <i/> // class from cssIcon
            onRenderTemplate: null,
            // function( index, template ) { return template; }, // template is a string
            onRenderHeader: null,
            // function( index ) {}, // nothing to return
            // *** functionality
            cancelSelection: true,
            // prevent text selection in the header
            tabIndex: true,
            // add tabindex to header for keyboard accessibility
            dateFormat: "mmddyyyy",
            // other options: 'ddmmyyy' or 'yyyymmdd'
            sortMultiSortKey: "shiftKey",
            // key used to select additional columns
            sortResetKey: "ctrlKey",
            // key used to remove sorting on a column
            usNumberFormat: true,
            // false for German '1.234.567,89' or French '1 234 567,89'
            delayInit: false,
            // if false, the parsed table contents will not update until the first sort
            serverSideSorting: false,
            // if true, server-side sorting should be performed because client-side sorting will be disabled, but the ui and events will still be used.
            resort: true,
            // default setting to trigger a resort after an 'update', 'addRows', 'updateCell', etc has completed
            // *** sort options
            headers: {},
            // set sorter, string, empty, locked order, sortInitialOrder, filter, etc.
            ignoreCase: true,
            // ignore case while sorting
            sortForce: null,
            // column(s) first sorted; always applied
            sortList: [],
            // Initial sort order; applied initially; updated when manually sorted
            sortAppend: null,
            // column(s) sorted last; always applied
            sortStable: false,
            // when sorting two rows with exactly the same content, the original sort order is maintained
            sortInitialOrder: "asc",
            // sort direction on first click
            sortLocaleCompare: false,
            // replace equivalent character (accented characters)
            sortReset: false,
            // third click on the header will reset column to default - unsorted
            sortRestart: false,
            // restart sort to 'sortInitialOrder' when clicking on previously unsorted columns
            emptyTo: "bottom",
            // sort empty cell to bottom, top, none, zero, emptyMax, emptyMin
            stringTo: "max",
            // sort strings in numerical column as max, min, top, bottom, zero
            duplicateSpan: true,
            // colspan cells in the tbody will have duplicated content in the cache for each spanned column
            textExtraction: "basic",
            // text extraction method/function - function( node, table, cellIndex ) {}
            textAttribute: "data-text",
            // data-attribute that contains alternate cell text (used in default textExtraction function)
            textSorter: null,
            // choose overall or specific column sorter function( a, b, direction, table, columnIndex ) [alt: ts.sortText]
            numberSorter: null,
            // choose overall numeric sorter function( a, b, direction, maxColumnValue )
            // *** widget options
            initWidgets: true,
            // apply widgets on tablesorter initialization
            widgetClass: "widget-{name}",
            // table class name template to match to include a widget
            widgets: [],
            // method to add widgets, e.g. widgets: ['zebra']
            widgetOptions: {
              zebra: ["even", "odd"]
              // zebra widget alternating row class names
            },
            // *** callbacks
            initialized: null,
            // function( table ) {},
            // *** extra css class names
            tableClass: "",
            cssAsc: "",
            cssDesc: "",
            cssNone: "",
            cssHeader: "",
            cssHeaderRow: "",
            cssProcessing: "",
            // processing icon applied to header during sort/filter
            cssChildRow: "tablesorter-childRow",
            // class name indiciating that a row is to be attached to its parent
            cssInfoBlock: "tablesorter-infoOnly",
            // don't sort tbody with this class name (only one class name allowed here!)
            cssNoSort: "tablesorter-noSort",
            // class name added to element inside header; clicking on it won't cause a sort
            cssIgnoreRow: "tablesorter-ignoreRow",
            // header row to ignore; cells within this row will not be added to c.$headers
            cssIcon: "tablesorter-icon",
            // if this class does not exist, the {icon} will not be added from the headerTemplate
            cssIconNone: "",
            // class name added to the icon when there is no column sort
            cssIconAsc: "",
            // class name added to the icon when the column has an ascending sort
            cssIconDesc: "",
            // class name added to the icon when the column has a descending sort
            cssIconDisabled: "",
            // class name added to the icon when the column has a disabled sort
            // *** events
            pointerClick: "click",
            pointerDown: "mousedown",
            pointerUp: "mouseup",
            // *** selectors
            selectorHeaders: "> thead th, > thead td",
            selectorSort: "th, td",
            // jQuery selector of content within selectorHeaders that is clickable to trigger a sort
            selectorRemove: ".remove-me",
            // *** advanced
            debug: false,
            // *** Internal variables
            headerList: [],
            empties: {},
            strings: {},
            parsers: [],
            // *** parser options for validator; values must be falsy!
            globalize: 0,
            imgAttr: 0
            // removed: widgetZebra: { css: ['even', 'odd'] }
          },
          // internal css classes - these will ALWAYS be added to
          // the table and MUST only contain one class name - fixes #381
          css: {
            table: "tablesorter",
            cssHasChild: "tablesorter-hasChildRow",
            childRow: "tablesorter-childRow",
            colgroup: "tablesorter-colgroup",
            header: "tablesorter-header",
            headerRow: "tablesorter-headerRow",
            headerIn: "tablesorter-header-inner",
            icon: "tablesorter-icon",
            processing: "tablesorter-processing",
            sortAsc: "tablesorter-headerAsc",
            sortDesc: "tablesorter-headerDesc",
            sortNone: "tablesorter-headerUnSorted"
          },
          // labels applied to sortable headers for accessibility (aria) support
          language: {
            sortAsc: "Ascending sort applied, ",
            sortDesc: "Descending sort applied, ",
            sortNone: "No sort applied, ",
            sortDisabled: "sorting is disabled",
            nextAsc: "activate to apply an ascending sort",
            nextDesc: "activate to apply a descending sort",
            nextNone: "activate to remove the sort"
          },
          regex: {
            templateContent: /\{content\}/g,
            templateIcon: /\{icon\}/g,
            templateName: /\{name\}/i,
            spaces: /\s+/g,
            nonWord: /\W/g,
            formElements: /(input|select|button|textarea)/i,
            // *** sort functions ***
            // regex used in natural sort
            // chunk/tokenize numbers & letters
            chunk: /(^([+\-]?(?:\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
            // replace chunks @ ends
            chunks: /(^\\0|\\0$)/,
            hex: /^0x[0-9a-f]+$/i,
            // *** formatFloat ***
            comma: /,/g,
            digitNonUS: /[\s|\.]/g,
            digitNegativeTest: /^\s*\([.\d]+\)/,
            digitNegativeReplace: /^\s*\(([.\d]+)\)/,
            // *** isDigit ***
            digitTest: /^[\-+(]?\d+[)]?$/,
            digitReplace: /[,.'"\s]/g
          },
          // digit sort, text location
          string: {
            max: 1,
            min: -1,
            emptymin: 1,
            emptymax: -1,
            zero: 0,
            none: 0,
            "null": 0,
            top: true,
            bottom: false
          },
          keyCodes: {
            enter: 13
          },
          // placeholder date parser data (globalize)
          dates: {},
          // These methods can be applied on table.config instance
          instanceMethods: {},
          /*
                
                         
                         
                  
          */
          setup: function(table, c) {
            if (!table || !table.tHead || table.tBodies.length === 0 || table.hasInitialized === true) {
              if (ts.debug(c, "core")) {
                if (table.hasInitialized) {
                  console.warn("Stopping initialization. Tablesorter has already been initialized");
                } else {
                  console.error("Stopping initialization! No table, thead or tbody", table);
                }
              }
              return;
            }
            var tmp = "", $table = $(table), meta = $.metadata;
            table.hasInitialized = false;
            table.isProcessing = true;
            table.config = c;
            $.data(table, "tablesorter", c);
            if (ts.debug(c, "core")) {
              console[console.group ? "group" : "log"]("Initializing tablesorter v" + ts.version);
              $.data(table, "startoveralltimer", /* @__PURE__ */ new Date());
            }
            c.supportsDataObject = function(version) {
              version[0] = parseInt(version[0], 10);
              return version[0] > 1 || version[0] === 1 && parseInt(version[1], 10) >= 4;
            }($.fn.jquery.split("."));
            c.emptyTo = c.emptyTo.toLowerCase();
            c.stringTo = c.stringTo.toLowerCase();
            c.last = { sortList: [], clickedIndex: -1 };
            if (!/tablesorter\-/.test($table.attr("class"))) {
              tmp = c.theme !== "" ? " tablesorter-" + c.theme : "";
            }
            if (!c.namespace) {
              c.namespace = ".tablesorter" + Math.random().toString(16).slice(2);
            } else {
              c.namespace = "." + c.namespace.replace(ts.regex.nonWord, "");
            }
            c.table = table;
            c.$table = $table.addClass(ts.css.table + " " + c.tableClass + tmp + " " + c.namespace.slice(1)).attr("role", "grid");
            c.$headers = $table.find(c.selectorHeaders);
            c.$table.children().children("tr").attr("role", "row");
            c.$tbodies = $table.children("tbody:not(." + c.cssInfoBlock + ")").attr({
              "aria-live": "polite",
              "aria-relevant": "all"
            });
            if (c.$table.children("caption").length) {
              tmp = c.$table.children("caption")[0];
              if (!tmp.id) {
                tmp.id = c.namespace.slice(1) + "caption";
              }
              c.$table.attr("aria-labelledby", tmp.id);
            }
            c.widgetInit = {};
            c.textExtraction = c.$table.attr("data-text-extraction") || c.textExtraction || "basic";
            ts.buildHeaders(c);
            ts.fixColumnWidth(table);
            ts.addWidgetFromClass(table);
            ts.applyWidgetOptions(table);
            ts.setupParsers(c);
            c.totalRows = 0;
            if (c.debug) {
              ts.validateOptions(c);
            }
            if (!c.delayInit) {
              ts.buildCache(c);
            }
            ts.bindEvents(table, c.$headers, true);
            ts.bindMethods(c);
            if (c.supportsDataObject && typeof $table.data().sortlist !== "undefined") {
              c.sortList = $table.data().sortlist;
            } else if (meta && ($table.metadata() && $table.metadata().sortlist)) {
              c.sortList = $table.metadata().sortlist;
            }
            ts.applyWidget(table, true);
            if (c.sortList.length > 0) {
              c.last.sortList = c.sortList;
              ts.sortOn(c, c.sortList, {}, !c.initWidgets);
            } else {
              ts.setHeadersCss(c);
              if (c.initWidgets) {
                ts.applyWidget(table, false);
              }
            }
            if (c.showProcessing) {
              $table.unbind("sortBegin" + c.namespace + " sortEnd" + c.namespace).bind("sortBegin" + c.namespace + " sortEnd" + c.namespace, function(e) {
                clearTimeout(c.timerProcessing);
                ts.isProcessing(table);
                if (e.type === "sortBegin") {
                  c.timerProcessing = setTimeout(function() {
                    ts.isProcessing(table, true);
                  }, 500);
                }
              });
            }
            table.hasInitialized = true;
            table.isProcessing = false;
            if (ts.debug(c, "core")) {
              console.log("Overall initialization time:" + ts.benchmark($.data(table, "startoveralltimer")));
              if (ts.debug(c, "core") && console.groupEnd) {
                console.groupEnd();
              }
            }
            $table.triggerHandler("tablesorter-initialized", table);
            if (typeof c.initialized === "function") {
              c.initialized(table);
            }
          },
          bindMethods: function(c) {
            var $table = c.$table, namespace = c.namespace, events = "sortReset update updateRows updateAll updateHeaders addRows updateCell updateComplete sorton appendCache updateCache applyWidgetId applyWidgets refreshWidgets destroy mouseup mouseleave ".split(" ").join(namespace + " ");
            $table.unbind(events.replace(ts.regex.spaces, " ")).bind("sortReset" + namespace, function(e, callback) {
              e.stopPropagation();
              ts.sortReset(this.config, function(table) {
                if (table.isApplyingWidgets) {
                  setTimeout(function() {
                    ts.applyWidget(table, "", callback);
                  }, 100);
                } else {
                  ts.applyWidget(table, "", callback);
                }
              });
            }).bind("updateAll" + namespace, function(e, resort, callback) {
              e.stopPropagation();
              ts.updateAll(this.config, resort, callback);
            }).bind("update" + namespace + " updateRows" + namespace, function(e, resort, callback) {
              e.stopPropagation();
              ts.update(this.config, resort, callback);
            }).bind("updateHeaders" + namespace, function(e, callback) {
              e.stopPropagation();
              ts.updateHeaders(this.config, callback);
            }).bind("updateCell" + namespace, function(e, cell, resort, callback) {
              e.stopPropagation();
              ts.updateCell(this.config, cell, resort, callback);
            }).bind("addRows" + namespace, function(e, $row, resort, callback) {
              e.stopPropagation();
              ts.addRows(this.config, $row, resort, callback);
            }).bind("updateComplete" + namespace, function() {
              this.isUpdating = false;
            }).bind("sorton" + namespace, function(e, list, callback, init) {
              e.stopPropagation();
              ts.sortOn(this.config, list, callback, init);
            }).bind("appendCache" + namespace, function(e, callback, init) {
              e.stopPropagation();
              ts.appendCache(this.config, init);
              if ($.isFunction(callback)) {
                callback(this);
              }
            }).bind("updateCache" + namespace, function(e, callback, $tbodies) {
              e.stopPropagation();
              ts.updateCache(this.config, callback, $tbodies);
            }).bind("applyWidgetId" + namespace, function(e, id) {
              e.stopPropagation();
              ts.applyWidgetId(this, id);
            }).bind("applyWidgets" + namespace, function(e, callback) {
              e.stopPropagation();
              ts.applyWidget(this, false, callback);
            }).bind("refreshWidgets" + namespace, function(e, all, dontapply) {
              e.stopPropagation();
              ts.refreshWidgets(this, all, dontapply);
            }).bind("removeWidget" + namespace, function(e, name, refreshing) {
              e.stopPropagation();
              ts.removeWidget(this, name, refreshing);
            }).bind("destroy" + namespace, function(e, removeClasses, callback) {
              e.stopPropagation();
              ts.destroy(this, removeClasses, callback);
            }).bind("resetToLoadState" + namespace, function(e) {
              e.stopPropagation();
              ts.removeWidget(this, true, false);
              var tmp = $.extend(true, {}, c.originalSettings);
              c = $.extend(true, {}, ts.defaults, tmp);
              c.originalSettings = tmp;
              this.hasInitialized = false;
              ts.setup(this, c);
            });
          },
          bindEvents: function(table, $headers, core) {
            table = $(table)[0];
            var tmp, c = table.config, namespace = c.namespace, downTarget = null;
            if (core !== true) {
              $headers.addClass(namespace.slice(1) + "_extra_headers");
              tmp = ts.getClosest($headers, "table");
              if (tmp.length && tmp[0].nodeName === "TABLE" && tmp[0] !== table) {
                $(tmp[0]).addClass(namespace.slice(1) + "_extra_table");
              }
            }
            tmp = (c.pointerDown + " " + c.pointerUp + " " + c.pointerClick + " sort keyup ").replace(ts.regex.spaces, " ").split(" ").join(namespace + " ");
            $headers.find(c.selectorSort).add($headers.filter(c.selectorSort)).unbind(tmp).bind(tmp, function(e, external) {
              var $cell, cell, temp, $target = $(e.target), type = " " + e.type + " ";
              if ((e.which || e.button) !== 1 && !type.match(" " + c.pointerClick + " | sort | keyup ") || // allow pressing enter
              type === " keyup " && e.which !== ts.keyCodes.enter || // allow triggering a click event (e.which is undefined) & ignore physical clicks
              type.match(" " + c.pointerClick + " ") && typeof e.which !== "undefined") {
                return;
              }
              if (type.match(" " + c.pointerUp + " ") && downTarget !== e.target && external !== true) {
                return;
              }
              if (type.match(" " + c.pointerDown + " ")) {
                downTarget = e.target;
                temp = $target.jquery.split(".");
                if (temp[0] === "1" && temp[1] < 4) {
                  e.preventDefault();
                }
                return;
              }
              downTarget = null;
              $cell = ts.getClosest($(this), "." + ts.css.header);
              if (ts.regex.formElements.test(e.target.nodeName) || // nosort class name, or elements within a nosort container
              $target.hasClass(c.cssNoSort) || $target.parents("." + c.cssNoSort).length > 0 || // disabled cell directly clicked
              $cell.hasClass("sorter-false") || // elements within a button
              $target.parents("button").length > 0) {
                return !c.cancelSelection;
              }
              if (c.delayInit && ts.isEmptyObject(c.cache)) {
                ts.buildCache(c);
              }
              c.last.clickedIndex = $cell.attr("data-column") || $cell.index();
              cell = c.$headerIndexed[c.last.clickedIndex][0];
              if (cell && !cell.sortDisabled) {
                ts.initSort(c, cell, e);
              }
            });
            if (c.cancelSelection) {
              $headers.attr("unselectable", "on").bind("selectstart", false).css({
                "user-select": "none",
                "MozUserSelect": "none"
                // not needed for jQuery 1.8+
              });
            }
          },
          buildHeaders: function(c) {
            var $temp, icon, timer, indx;
            c.headerList = [];
            c.headerContent = [];
            c.sortVars = [];
            if (ts.debug(c, "core")) {
              timer = /* @__PURE__ */ new Date();
            }
            c.columns = ts.computeColumnIndex(c.$table.children("thead, tfoot").children("tr"));
            icon = c.cssIcon ? '<i class="' + (c.cssIcon === ts.css.icon ? ts.css.icon : c.cssIcon + " " + ts.css.icon) + '"></i>' : "";
            c.$headers = $($.map(c.$table.find(c.selectorHeaders), function(elem, index) {
              var configHeaders, header, column, template, tmp, $elem = $(elem);
              if (ts.getClosest($elem, "tr").hasClass(c.cssIgnoreRow)) {
                return;
              }
              if (!/(th|td)/i.test(elem.nodeName)) {
                tmp = ts.getClosest($elem, "th, td");
                $elem.attr("data-column", tmp.attr("data-column"));
              }
              configHeaders = ts.getColumnData(c.table, c.headers, index, true);
              c.headerContent[index] = $elem.html();
              if (c.headerTemplate !== "" && !$elem.find("." + ts.css.headerIn).length) {
                template = c.headerTemplate.replace(ts.regex.templateContent, $elem.html()).replace(ts.regex.templateIcon, $elem.find("." + ts.css.icon).length ? "" : icon);
                if (c.onRenderTemplate) {
                  header = c.onRenderTemplate.apply($elem, [index, template]);
                  if (header && typeof header === "string") {
                    template = header;
                  }
                }
                $elem.html('<div class="' + ts.css.headerIn + '">' + template + "</div>");
              }
              if (c.onRenderHeader) {
                c.onRenderHeader.apply($elem, [index, c, c.$table]);
              }
              column = parseInt($elem.attr("data-column"), 10);
              elem.column = column;
              tmp = ts.getOrder(ts.getData($elem, configHeaders, "sortInitialOrder") || c.sortInitialOrder);
              c.sortVars[column] = {
                count: -1,
                // set to -1 because clicking on the header automatically adds one
                order: tmp ? c.sortReset ? [1, 0, 2] : [1, 0] : (
                  // desc, asc, unsorted
                  c.sortReset ? [0, 1, 2] : [0, 1]
                ),
                // asc, desc, unsorted
                lockedOrder: false,
                sortedBy: ""
              };
              tmp = ts.getData($elem, configHeaders, "lockedOrder") || false;
              if (typeof tmp !== "undefined" && tmp !== false) {
                c.sortVars[column].lockedOrder = true;
                c.sortVars[column].order = ts.getOrder(tmp) ? [1, 1] : [0, 0];
              }
              c.headerList[index] = elem;
              $elem.addClass(ts.css.header + " " + c.cssHeader);
              ts.getClosest($elem, "tr").addClass(ts.css.headerRow + " " + c.cssHeaderRow).attr("role", "row");
              if (c.tabIndex) {
                $elem.attr("tabindex", 0);
              }
              return elem;
            }));
            c.$headerIndexed = [];
            for (indx = 0; indx < c.columns; indx++) {
              if (ts.isEmptyObject(c.sortVars[indx])) {
                c.sortVars[indx] = {};
              }
              $temp = c.$headers.filter('[data-column="' + indx + '"]');
              c.$headerIndexed[indx] = $temp.length ? $temp.not(".sorter-false").length ? $temp.not(".sorter-false").filter(":last") : $temp.filter(":last") : $();
            }
            c.$table.find(c.selectorHeaders).attr({
              scope: "col",
              role: "columnheader"
            });
            ts.updateHeader(c);
            if (ts.debug(c, "core")) {
              console.log("Built headers:" + ts.benchmark(timer));
              console.log(c.$headers);
            }
          },
          // Use it to add a set of methods to table.config which will be available for all tables.
          // This should be done before table initialization
          addInstanceMethods: function(methods) {
            $.extend(ts.instanceMethods, methods);
          },
          /*
                
                     
                           
                          
          */
          setupParsers: function(c, $tbodies) {
            var rows, list, span, max, colIndex, indx, header, configHeaders, noParser, parser, extractor, time, tbody, len, table = c.table, tbodyIndex = 0, debug = ts.debug(c, "core"), debugOutput = {};
            c.$tbodies = c.$table.children("tbody:not(." + c.cssInfoBlock + ")");
            tbody = typeof $tbodies === "undefined" ? c.$tbodies : $tbodies;
            len = tbody.length;
            if (len === 0) {
              return debug ? console.warn("Warning: *Empty table!* Not building a parser cache") : "";
            } else if (debug) {
              time = /* @__PURE__ */ new Date();
              console[console.group ? "group" : "log"]("Detecting parsers for each column");
            }
            list = {
              extractors: [],
              parsers: []
            };
            while (tbodyIndex < len) {
              rows = tbody[tbodyIndex].rows;
              if (rows.length) {
                colIndex = 0;
                max = c.columns;
                for (indx = 0; indx < max; indx++) {
                  header = c.$headerIndexed[colIndex];
                  if (header && header.length) {
                    configHeaders = ts.getColumnData(table, c.headers, colIndex);
                    extractor = ts.getParserById(ts.getData(header, configHeaders, "extractor"));
                    parser = ts.getParserById(ts.getData(header, configHeaders, "sorter"));
                    noParser = ts.getData(header, configHeaders, "parser") === "false";
                    c.empties[colIndex] = (ts.getData(header, configHeaders, "empty") || c.emptyTo || (c.emptyToBottom ? "bottom" : "top")).toLowerCase();
                    c.strings[colIndex] = (ts.getData(header, configHeaders, "string") || c.stringTo || "max").toLowerCase();
                    if (noParser) {
                      parser = ts.getParserById("no-parser");
                    }
                    if (!extractor) {
                      extractor = false;
                    }
                    if (!parser) {
                      parser = ts.detectParserForColumn(c, rows, -1, colIndex);
                    }
                    if (debug) {
                      debugOutput["(" + colIndex + ") " + header.text()] = {
                        parser: parser.id,
                        extractor: extractor ? extractor.id : "none",
                        string: c.strings[colIndex],
                        empty: c.empties[colIndex]
                      };
                    }
                    list.parsers[colIndex] = parser;
                    list.extractors[colIndex] = extractor;
                    span = header[0].colSpan - 1;
                    if (span > 0) {
                      colIndex += span;
                      max += span;
                      while (span + 1 > 0) {
                        list.parsers[colIndex - span] = parser;
                        list.extractors[colIndex - span] = extractor;
                        span--;
                      }
                    }
                  }
                  colIndex++;
                }
              }
              tbodyIndex += list.parsers.length ? len : 1;
            }
            if (debug) {
              if (!ts.isEmptyObject(debugOutput)) {
                console[console.table ? "table" : "log"](debugOutput);
              } else {
                console.warn("  No parsers detected!");
              }
              console.log("Completed detecting parsers" + ts.benchmark(time));
              if (console.groupEnd) {
                console.groupEnd();
              }
            }
            c.parsers = list.parsers;
            c.extractors = list.extractors;
          },
          addParser: function(parser) {
            var indx, len = ts.parsers.length, add = true;
            for (indx = 0; indx < len; indx++) {
              if (ts.parsers[indx].id.toLowerCase() === parser.id.toLowerCase()) {
                add = false;
              }
            }
            if (add) {
              ts.parsers[ts.parsers.length] = parser;
            }
          },
          getParserById: function(name) {
            if (name == "false") {
              return false;
            }
            var indx, len = ts.parsers.length;
            for (indx = 0; indx < len; indx++) {
              if (ts.parsers[indx].id.toLowerCase() === name.toString().toLowerCase()) {
                return ts.parsers[indx];
              }
            }
            return false;
          },
          detectParserForColumn: function(c, rows, rowIndex, cellIndex) {
            var cur, $node, row, indx = ts.parsers.length, node = false, nodeValue = "", debug = ts.debug(c, "core"), keepLooking = true;
            while (nodeValue === "" && keepLooking) {
              rowIndex++;
              row = rows[rowIndex];
              if (row && rowIndex < 50) {
                if (row.className.indexOf(ts.cssIgnoreRow) < 0) {
                  node = rows[rowIndex].cells[cellIndex];
                  nodeValue = ts.getElementText(c, node, cellIndex);
                  $node = $(node);
                  if (debug) {
                    console.log("Checking if value was empty on row " + rowIndex + ", column: " + cellIndex + ': "' + nodeValue + '"');
                  }
                }
              } else {
                keepLooking = false;
              }
            }
            while (--indx >= 0) {
              cur = ts.parsers[indx];
              if (cur && cur.id !== "text" && cur.is && cur.is(nodeValue, c.table, node, $node)) {
                return cur;
              }
            }
            return ts.getParserById("text");
          },
          getElementText: function(c, node, cellIndex) {
            if (!node) {
              return "";
            }
            var tmp, extract = c.textExtraction || "", $node = node.jquery ? node : $(node);
            if (typeof extract === "string") {
              if (extract === "basic" && typeof (tmp = $node.attr(c.textAttribute)) !== "undefined") {
                return $.trim(tmp);
              }
              return $.trim(node.textContent || $node.text());
            } else {
              if (typeof extract === "function") {
                return $.trim(extract($node[0], c.table, cellIndex));
              } else if (typeof (tmp = ts.getColumnData(c.table, extract, cellIndex)) === "function") {
                return $.trim(tmp($node[0], c.table, cellIndex));
              }
            }
            return $.trim($node[0].textContent || $node.text());
          },
          // centralized function to extract/parse cell contents
          getParsedText: function(c, cell, colIndex, txt) {
            if (typeof txt === "undefined") {
              txt = ts.getElementText(c, cell, colIndex);
            }
            var val = "" + txt, parser = c.parsers[colIndex], extractor = c.extractors[colIndex];
            if (parser) {
              if (extractor && typeof extractor.format === "function") {
                txt = extractor.format(txt, c.table, cell, colIndex);
              }
              val = parser.id === "no-parser" ? "" : (
                // make sure txt is a string (extractor may have converted it)
                parser.format("" + txt, c.table, cell, colIndex)
              );
              if (c.ignoreCase && typeof val === "string") {
                val = val.toLowerCase();
              }
            }
            return val;
          },
          /*
                
                  
                  
                  
          */
          buildCache: function(c, callback, $tbodies) {
            var cache, val, txt, rowIndex, colIndex, tbodyIndex, $tbody, $row, cols, $cells, cell, cacheTime, totalRows, rowData, prevRowData, colMax, span, cacheIndex, hasParser, max, len, index, table = c.table, parsers = c.parsers, debug = ts.debug(c, "core");
            c.$tbodies = c.$table.children("tbody:not(." + c.cssInfoBlock + ")");
            $tbody = typeof $tbodies === "undefined" ? c.$tbodies : $tbodies, c.cache = {};
            c.totalRows = 0;
            if (!parsers) {
              return debug ? console.warn("Warning: *Empty table!* Not building a cache") : "";
            }
            if (debug) {
              cacheTime = /* @__PURE__ */ new Date();
            }
            if (c.showProcessing) {
              ts.isProcessing(table, true);
            }
            for (tbodyIndex = 0; tbodyIndex < $tbody.length; tbodyIndex++) {
              colMax = [];
              cache = c.cache[tbodyIndex] = {
                normalized: []
                // array of normalized row data; last entry contains 'rowData' above
                // colMax: #   // added at the end
              };
              totalRows = $tbody[tbodyIndex] && $tbody[tbodyIndex].rows.length || 0;
              for (rowIndex = 0; rowIndex < totalRows; ++rowIndex) {
                rowData = {
                  // order: original row order #
                  // $row : jQuery Object[]
                  child: [],
                  // child row text (filter widget)
                  raw: []
                  // original row text
                };
                $row = $($tbody[tbodyIndex].rows[rowIndex]);
                cols = [];
                if ($row.hasClass(c.selectorRemove.slice(1))) {
                  continue;
                }
                if ($row.hasClass(c.cssChildRow) && rowIndex !== 0) {
                  len = cache.normalized.length - 1;
                  prevRowData = cache.normalized[len][c.columns];
                  prevRowData.$row = prevRowData.$row.add($row);
                  if (!$row.prev().hasClass(c.cssChildRow)) {
                    $row.prev().addClass(ts.css.cssHasChild);
                  }
                  $cells = $row.children("th, td");
                  len = prevRowData.child.length;
                  prevRowData.child[len] = [];
                  cacheIndex = 0;
                  max = c.columns;
                  for (colIndex = 0; colIndex < max; colIndex++) {
                    cell = $cells[colIndex];
                    if (cell) {
                      prevRowData.child[len][colIndex] = ts.getParsedText(c, cell, colIndex);
                      span = $cells[colIndex].colSpan - 1;
                      if (span > 0) {
                        cacheIndex += span;
                        max += span;
                      }
                    }
                    cacheIndex++;
                  }
                  continue;
                }
                rowData.$row = $row;
                rowData.order = rowIndex;
                cacheIndex = 0;
                max = c.columns;
                for (colIndex = 0; colIndex < max; ++colIndex) {
                  cell = $row[0].cells[colIndex];
                  if (cell && cacheIndex < c.columns) {
                    hasParser = typeof parsers[cacheIndex] !== "undefined";
                    if (!hasParser && debug) {
                      console.warn("No parser found for row: " + rowIndex + ", column: " + colIndex + '; cell containing: "' + $(cell).text() + '"; does it have a header?');
                    }
                    val = ts.getElementText(c, cell, cacheIndex);
                    rowData.raw[cacheIndex] = val;
                    txt = ts.getParsedText(c, cell, cacheIndex, val);
                    cols[cacheIndex] = txt;
                    if (hasParser && (parsers[cacheIndex].type || "").toLowerCase() === "numeric") {
                      colMax[cacheIndex] = Math.max(Math.abs(txt) || 0, colMax[cacheIndex] || 0);
                    }
                    span = cell.colSpan - 1;
                    if (span > 0) {
                      index = 0;
                      while (index <= span) {
                        txt = c.duplicateSpan || index === 0 ? txt : typeof c.textExtraction !== "string" ? ts.getElementText(c, cell, cacheIndex + index) || "" : "";
                        rowData.raw[cacheIndex + index] = txt;
                        cols[cacheIndex + index] = txt;
                        index++;
                      }
                      cacheIndex += span;
                      max += span;
                    }
                  }
                  cacheIndex++;
                }
                cols[c.columns] = rowData;
                cache.normalized[cache.normalized.length] = cols;
              }
              cache.colMax = colMax;
              c.totalRows += cache.normalized.length;
            }
            if (c.showProcessing) {
              ts.isProcessing(table);
            }
            if (debug) {
              len = Math.min(5, c.cache[0].normalized.length);
              console[console.group ? "group" : "log"]("Building cache for " + c.totalRows + " rows (showing " + len + " rows in log) and " + c.columns + " columns" + ts.benchmark(cacheTime));
              val = {};
              for (colIndex = 0; colIndex < c.columns; colIndex++) {
                for (cacheIndex = 0; cacheIndex < len; cacheIndex++) {
                  if (!val["row: " + cacheIndex]) {
                    val["row: " + cacheIndex] = {};
                  }
                  val["row: " + cacheIndex][c.$headerIndexed[colIndex].text()] = c.cache[0].normalized[cacheIndex][colIndex];
                }
              }
              console[console.table ? "table" : "log"](val);
              if (console.groupEnd) {
                console.groupEnd();
              }
            }
            if ($.isFunction(callback)) {
              callback(table);
            }
          },
          getColumnText: function(table, column, callback, rowFilter) {
            table = $(table)[0];
            var tbodyIndex, rowIndex, cache, row, tbodyLen, rowLen, raw, parsed, $cell, result, hasCallback = typeof callback === "function", allColumns = column === "all", data = { raw: [], parsed: [], $cell: [] }, c = table.config;
            if (ts.isEmptyObject(c)) {
              if (ts.debug(c, "core")) {
                console.warn("No cache found - aborting getColumnText function!");
              }
            } else {
              tbodyLen = c.$tbodies.length;
              for (tbodyIndex = 0; tbodyIndex < tbodyLen; tbodyIndex++) {
                cache = c.cache[tbodyIndex].normalized;
                rowLen = cache.length;
                for (rowIndex = 0; rowIndex < rowLen; rowIndex++) {
                  row = cache[rowIndex];
                  if (rowFilter && !row[c.columns].$row.is(rowFilter)) {
                    continue;
                  }
                  result = true;
                  parsed = allColumns ? row.slice(0, c.columns) : row[column];
                  row = row[c.columns];
                  raw = allColumns ? row.raw : row.raw[column];
                  $cell = allColumns ? row.$row.children() : row.$row.children().eq(column);
                  if (hasCallback) {
                    result = callback({
                      tbodyIndex,
                      rowIndex,
                      parsed,
                      raw,
                      $row: row.$row,
                      $cell
                    });
                  }
                  if (result !== false) {
                    data.parsed[data.parsed.length] = parsed;
                    data.raw[data.raw.length] = raw;
                    data.$cell[data.$cell.length] = $cell;
                  }
                }
              }
              return data;
            }
          },
          /*
                 
                       
                        
                         
          */
          setHeadersCss: function(c) {
            var indx, column, list = c.sortList, len = list.length, none = ts.css.sortNone + " " + c.cssNone, css = [ts.css.sortAsc + " " + c.cssAsc, ts.css.sortDesc + " " + c.cssDesc], cssIcon = [c.cssIconAsc, c.cssIconDesc, c.cssIconNone], aria = ["ascending", "descending"], updateColumnSort = function($el, index) {
              $el.removeClass(none).addClass(css[index]).attr("aria-sort", aria[index]).find("." + ts.css.icon).removeClass(cssIcon[2]).addClass(cssIcon[index]);
            }, $extras = c.$table.find("tfoot tr").children("td, th").add($(c.namespace + "_extra_headers")).removeClass(css.join(" ")), $sorted = c.$headers.add($("thead " + c.namespace + "_extra_headers")).removeClass(css.join(" ")).addClass(none).attr("aria-sort", "none").find("." + ts.css.icon).removeClass(cssIcon.join(" ")).end();
            $sorted.not(".sorter-false").find("." + ts.css.icon).addClass(cssIcon[2]);
            if (c.cssIconDisabled) {
              $sorted.filter(".sorter-false").find("." + ts.css.icon).addClass(c.cssIconDisabled);
            }
            for (indx = 0; indx < len; indx++) {
              if (list[indx][1] !== 2) {
                $sorted = c.$headers.filter(function(i) {
                  var include = true, $el = c.$headers.eq(i), col = parseInt($el.attr("data-column"), 10), end = col + ts.getClosest($el, "th, td")[0].colSpan;
                  for (; col < end; col++) {
                    include = include ? include || ts.isValueInArray(col, c.sortList) > -1 : false;
                  }
                  return include;
                });
                $sorted = $sorted.not(".sorter-false").filter('[data-column="' + list[indx][0] + '"]' + (len === 1 ? ":last" : ""));
                if ($sorted.length) {
                  for (column = 0; column < $sorted.length; column++) {
                    if (!$sorted[column].sortDisabled) {
                      updateColumnSort($sorted.eq(column), list[indx][1]);
                    }
                  }
                }
                if ($extras.length) {
                  updateColumnSort($extras.filter('[data-column="' + list[indx][0] + '"]'), list[indx][1]);
                }
              }
            }
            len = c.$headers.length;
            for (indx = 0; indx < len; indx++) {
              ts.setColumnAriaLabel(c, c.$headers.eq(indx));
            }
          },
          getClosest: function($el, selector) {
            if ($.fn.closest) {
              return $el.closest(selector);
            }
            return $el.is(selector) ? $el : $el.parents(selector).filter(":first");
          },
          // nextSort (optional), lets you disable next sort text
          setColumnAriaLabel: function(c, $header, nextSort) {
            if ($header.length) {
              var column = parseInt($header.attr("data-column"), 10), vars = c.sortVars[column], tmp = $header.hasClass(ts.css.sortAsc) ? "sortAsc" : $header.hasClass(ts.css.sortDesc) ? "sortDesc" : "sortNone", txt = $.trim($header.text()) + ": " + ts.language[tmp];
              if ($header.hasClass("sorter-false") || nextSort === false) {
                txt += ts.language.sortDisabled;
              } else {
                tmp = (vars.count + 1) % vars.order.length;
                nextSort = vars.order[tmp];
                txt += ts.language[nextSort === 0 ? "nextAsc" : nextSort === 1 ? "nextDesc" : "nextNone"];
              }
              $header.attr("aria-label", txt);
              if (vars.sortedBy) {
                $header.attr("data-sortedBy", vars.sortedBy);
              } else {
                $header.removeAttr("data-sortedBy");
              }
            }
          },
          updateHeader: function(c) {
            var index, isDisabled, $header, col, table = c.table, len = c.$headers.length;
            for (index = 0; index < len; index++) {
              $header = c.$headers.eq(index);
              col = ts.getColumnData(table, c.headers, index, true);
              isDisabled = ts.getData($header, col, "sorter") === "false" || ts.getData($header, col, "parser") === "false";
              ts.setColumnSort(c, $header, isDisabled);
            }
          },
          setColumnSort: function(c, $header, isDisabled) {
            var id = c.table.id;
            $header[0].sortDisabled = isDisabled;
            $header[isDisabled ? "addClass" : "removeClass"]("sorter-false").attr("aria-disabled", "" + isDisabled);
            if (c.tabIndex) {
              if (isDisabled) {
                $header.removeAttr("tabindex");
              } else {
                $header.attr("tabindex", "0");
              }
            }
            if (id) {
              if (isDisabled) {
                $header.removeAttr("aria-controls");
              } else {
                $header.attr("aria-controls", id);
              }
            }
          },
          updateHeaderSortCount: function(c, list) {
            var col, dir, group, indx, primary, temp, val, order, sortList = list || c.sortList, len = sortList.length;
            c.sortList = [];
            for (indx = 0; indx < len; indx++) {
              val = sortList[indx];
              col = parseInt(val[0], 10);
              if (col < c.columns) {
                if (!c.sortVars[col].order) {
                  if (ts.getOrder(c.sortInitialOrder)) {
                    order = c.sortReset ? [1, 0, 2] : [1, 0];
                  } else {
                    order = c.sortReset ? [0, 1, 2] : [0, 1];
                  }
                  c.sortVars[col].order = order;
                  c.sortVars[col].count = 0;
                }
                order = c.sortVars[col].order;
                dir = ("" + val[1]).match(/^(1|d|s|o|n)/);
                dir = dir ? dir[0] : "";
                switch (dir) {
                  case "1":
                  case "d":
                    dir = 1;
                    break;
                  case "s":
                    dir = primary || 0;
                    break;
                  case "o":
                    temp = order[(primary || 0) % order.length];
                    dir = temp === 0 ? 1 : temp === 1 ? 0 : 2;
                    break;
                  case "n":
                    dir = order[++c.sortVars[col].count % order.length];
                    break;
                  default:
                    dir = 0;
                    break;
                }
                primary = indx === 0 ? dir : primary;
                group = [col, parseInt(dir, 10) || 0];
                c.sortList[c.sortList.length] = group;
                dir = $.inArray(group[1], order);
                c.sortVars[col].count = dir >= 0 ? dir : group[1] % order.length;
              }
            }
          },
          updateAll: function(c, resort, callback) {
            var table = c.table;
            table.isUpdating = true;
            ts.refreshWidgets(table, true, true);
            ts.buildHeaders(c);
            ts.bindEvents(table, c.$headers, true);
            ts.bindMethods(c);
            ts.commonUpdate(c, resort, callback);
          },
          update: function(c, resort, callback) {
            var table = c.table;
            table.isUpdating = true;
            ts.updateHeader(c);
            ts.commonUpdate(c, resort, callback);
          },
          // simple header update - see #989
          updateHeaders: function(c, callback) {
            c.table.isUpdating = true;
            ts.buildHeaders(c);
            ts.bindEvents(c.table, c.$headers, true);
            ts.resortComplete(c, callback);
          },
          updateCell: function(c, cell, resort, callback) {
            if ($(cell).closest("tr").hasClass(c.cssChildRow)) {
              console.warn('Tablesorter Warning! "updateCell" for child row content has been disabled, use "update" instead');
              return;
            }
            if (ts.isEmptyObject(c.cache)) {
              ts.updateHeader(c);
              ts.commonUpdate(c, resort, callback);
              return;
            }
            c.table.isUpdating = true;
            c.$table.find(c.selectorRemove).remove();
            var tmp, indx, row, icell, cache, len, $tbodies = c.$tbodies, $cell = $(cell), tbodyIndex = $tbodies.index(ts.getClosest($cell, "tbody")), tbcache = c.cache[tbodyIndex], $row = ts.getClosest($cell, "tr");
            cell = $cell[0];
            if ($tbodies.length && tbodyIndex >= 0) {
              row = $tbodies.eq(tbodyIndex).find("tr").not("." + c.cssChildRow).index($row);
              cache = tbcache.normalized[row];
              len = $row[0].cells.length;
              if (len !== c.columns) {
                icell = 0;
                tmp = false;
                for (indx = 0; indx < len; indx++) {
                  if (!tmp && $row[0].cells[indx] !== cell) {
                    icell += $row[0].cells[indx].colSpan;
                  } else {
                    tmp = true;
                  }
                }
              } else {
                icell = $cell.index();
              }
              tmp = ts.getElementText(c, cell, icell);
              cache[c.columns].raw[icell] = tmp;
              tmp = ts.getParsedText(c, cell, icell, tmp);
              cache[icell] = tmp;
              if ((c.parsers[icell].type || "").toLowerCase() === "numeric") {
                tbcache.colMax[icell] = Math.max(Math.abs(tmp) || 0, tbcache.colMax[icell] || 0);
              }
              tmp = resort !== "undefined" ? resort : c.resort;
              if (tmp !== false) {
                ts.checkResort(c, tmp, callback);
              } else {
                ts.resortComplete(c, callback);
              }
            } else {
              if (ts.debug(c, "core")) {
                console.error("updateCell aborted, tbody missing or not within the indicated table");
              }
              c.table.isUpdating = false;
            }
          },
          addRows: function(c, $row, resort, callback) {
            var txt, val, tbodyIndex, rowIndex, rows, cellIndex, len, order, cacheIndex, rowData, cells, cell, span, valid = typeof $row === "string" && c.$tbodies.length === 1 && /<tr/.test($row || ""), table = c.table;
            if (valid) {
              $row = $($row);
              c.$tbodies.append($row);
            } else if (!$row || // row is a jQuery object?
            !($row instanceof $) || // row contained in the table?
            ts.getClosest($row, "table")[0] !== c.table) {
              if (ts.debug(c, "core")) {
                console.error("addRows method requires (1) a jQuery selector reference to rows that have already been added to the table, or (2) row HTML string to be added to a table with only one tbody");
              }
              return false;
            }
            table.isUpdating = true;
            if (ts.isEmptyObject(c.cache)) {
              ts.updateHeader(c);
              ts.commonUpdate(c, resort, callback);
            } else {
              rows = $row.filter("tr").attr("role", "row").length;
              tbodyIndex = c.$tbodies.index($row.parents("tbody").filter(":first"));
              if (!(c.parsers && c.parsers.length)) {
                ts.setupParsers(c);
              }
              for (rowIndex = 0; rowIndex < rows; rowIndex++) {
                cacheIndex = 0;
                len = $row[rowIndex].cells.length;
                order = c.cache[tbodyIndex].normalized.length;
                cells = [];
                rowData = {
                  child: [],
                  raw: [],
                  $row: $row.eq(rowIndex),
                  order
                };
                for (cellIndex = 0; cellIndex < len; cellIndex++) {
                  cell = $row[rowIndex].cells[cellIndex];
                  txt = ts.getElementText(c, cell, cacheIndex);
                  rowData.raw[cacheIndex] = txt;
                  val = ts.getParsedText(c, cell, cacheIndex, txt);
                  cells[cacheIndex] = val;
                  if ((c.parsers[cacheIndex].type || "").toLowerCase() === "numeric") {
                    c.cache[tbodyIndex].colMax[cacheIndex] = Math.max(Math.abs(val) || 0, c.cache[tbodyIndex].colMax[cacheIndex] || 0);
                  }
                  span = cell.colSpan - 1;
                  if (span > 0) {
                    cacheIndex += span;
                  }
                  cacheIndex++;
                }
                cells[c.columns] = rowData;
                c.cache[tbodyIndex].normalized[order] = cells;
              }
              ts.checkResort(c, resort, callback);
            }
          },
          updateCache: function(c, callback, $tbodies) {
            if (!(c.parsers && c.parsers.length)) {
              ts.setupParsers(c, $tbodies);
            }
            ts.buildCache(c, callback, $tbodies);
          },
          // init flag (true) used by pager plugin to prevent widget application
          // renamed from appendToTable
          appendCache: function(c, init) {
            var parsed, totalRows, $tbody, $curTbody, rowIndex, tbodyIndex, appendTime, table = c.table, $tbodies = c.$tbodies, rows = [], cache = c.cache;
            if (ts.isEmptyObject(cache)) {
              return c.appender ? c.appender(table, rows) : table.isUpdating ? c.$table.triggerHandler("updateComplete", table) : "";
            }
            if (ts.debug(c, "core")) {
              appendTime = /* @__PURE__ */ new Date();
            }
            for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++) {
              $tbody = $tbodies.eq(tbodyIndex);
              if ($tbody.length) {
                $curTbody = ts.processTbody(table, $tbody, true);
                parsed = cache[tbodyIndex].normalized;
                totalRows = parsed.length;
                for (rowIndex = 0; rowIndex < totalRows; rowIndex++) {
                  rows[rows.length] = parsed[rowIndex][c.columns].$row;
                  if (!c.appender || c.pager && !c.pager.removeRows && !c.pager.ajax) {
                    $curTbody.append(parsed[rowIndex][c.columns].$row);
                  }
                }
                ts.processTbody(table, $curTbody, false);
              }
            }
            if (c.appender) {
              c.appender(table, rows);
            }
            if (ts.debug(c, "core")) {
              console.log("Rebuilt table" + ts.benchmark(appendTime));
            }
            if (!init && !c.appender) {
              ts.applyWidget(table);
            }
            if (table.isUpdating) {
              c.$table.triggerHandler("updateComplete", table);
            }
          },
          commonUpdate: function(c, resort, callback) {
            c.$table.find(c.selectorRemove).remove();
            ts.setupParsers(c);
            ts.buildCache(c);
            ts.checkResort(c, resort, callback);
          },
          /*
                
                            
                             
                        
          */
          initSort: function(c, cell, event) {
            if (c.table.isUpdating) {
              return setTimeout(function() {
                ts.initSort(c, cell, event);
              }, 50);
            }
            var arry, indx, headerIndx, dir, temp, tmp, $header, notMultiSort = !event[c.sortMultiSortKey], table = c.table, len = c.$headers.length, th = ts.getClosest($(cell), "th, td"), col = parseInt(th.attr("data-column"), 10), sortedBy = event.type === "mouseup" ? "user" : event.type, order = c.sortVars[col].order;
            th = th[0];
            c.$table.triggerHandler("sortStart", table);
            tmp = (c.sortVars[col].count + 1) % order.length;
            c.sortVars[col].count = event[c.sortResetKey] ? 2 : tmp;
            if (c.sortRestart) {
              for (headerIndx = 0; headerIndx < len; headerIndx++) {
                $header = c.$headers.eq(headerIndx);
                tmp = parseInt($header.attr("data-column"), 10);
                if (col !== tmp && (notMultiSort || $header.hasClass(ts.css.sortNone))) {
                  c.sortVars[tmp].count = -1;
                }
              }
            }
            if (notMultiSort) {
              $.each(c.sortVars, function(i) {
                c.sortVars[i].sortedBy = "";
              });
              c.sortList = [];
              c.last.sortList = [];
              if (c.sortForce !== null) {
                arry = c.sortForce;
                for (indx = 0; indx < arry.length; indx++) {
                  if (arry[indx][0] !== col) {
                    c.sortList[c.sortList.length] = arry[indx];
                    c.sortVars[arry[indx][0]].sortedBy = "sortForce";
                  }
                }
              }
              dir = order[c.sortVars[col].count];
              if (dir < 2) {
                c.sortList[c.sortList.length] = [col, dir];
                c.sortVars[col].sortedBy = sortedBy;
                if (th.colSpan > 1) {
                  for (indx = 1; indx < th.colSpan; indx++) {
                    c.sortList[c.sortList.length] = [col + indx, dir];
                    c.sortVars[col + indx].count = $.inArray(dir, order);
                    c.sortVars[col + indx].sortedBy = sortedBy;
                  }
                }
              }
            } else {
              c.sortList = $.extend([], c.last.sortList);
              if (ts.isValueInArray(col, c.sortList) >= 0) {
                c.sortVars[col].sortedBy = sortedBy;
                for (indx = 0; indx < c.sortList.length; indx++) {
                  tmp = c.sortList[indx];
                  if (tmp[0] === col) {
                    tmp[1] = order[c.sortVars[col].count];
                    if (tmp[1] === 2) {
                      c.sortList.splice(indx, 1);
                      c.sortVars[col].count = -1;
                    }
                  }
                }
              } else {
                dir = order[c.sortVars[col].count];
                c.sortVars[col].sortedBy = sortedBy;
                if (dir < 2) {
                  c.sortList[c.sortList.length] = [col, dir];
                  if (th.colSpan > 1) {
                    for (indx = 1; indx < th.colSpan; indx++) {
                      c.sortList[c.sortList.length] = [col + indx, dir];
                      c.sortVars[col + indx].count = $.inArray(dir, order);
                      c.sortVars[col + indx].sortedBy = sortedBy;
                    }
                  }
                }
              }
            }
            c.last.sortList = $.extend([], c.sortList);
            if (c.sortList.length && c.sortAppend) {
              arry = $.isArray(c.sortAppend) ? c.sortAppend : c.sortAppend[c.sortList[0][0]];
              if (!ts.isEmptyObject(arry)) {
                for (indx = 0; indx < arry.length; indx++) {
                  if (arry[indx][0] !== col && ts.isValueInArray(arry[indx][0], c.sortList) < 0) {
                    dir = arry[indx][1];
                    temp = ("" + dir).match(/^(a|d|s|o|n)/);
                    if (temp) {
                      tmp = c.sortList[0][1];
                      switch (temp[0]) {
                        case "d":
                          dir = 1;
                          break;
                        case "s":
                          dir = tmp;
                          break;
                        case "o":
                          dir = tmp === 0 ? 1 : 0;
                          break;
                        case "n":
                          dir = (tmp + 1) % order.length;
                          break;
                        default:
                          dir = 0;
                          break;
                      }
                    }
                    c.sortList[c.sortList.length] = [arry[indx][0], dir];
                    c.sortVars[arry[indx][0]].sortedBy = "sortAppend";
                  }
                }
              }
            }
            c.$table.triggerHandler("sortBegin", table);
            setTimeout(function() {
              ts.setHeadersCss(c);
              ts.multisort(c);
              ts.appendCache(c);
              c.$table.triggerHandler("sortBeforeEnd", table);
              c.$table.triggerHandler("sortEnd", table);
            }, 1);
          },
          // sort multiple columns
          multisort: function(c) {
            var tbodyIndex, sortTime, colMax, rows, tmp, table = c.table, sorter = [], dir = 0, textSorter = c.textSorter || "", sortList = c.sortList, sortLen = sortList.length, len = c.$tbodies.length;
            if (c.serverSideSorting || ts.isEmptyObject(c.cache)) {
              return;
            }
            if (ts.debug(c, "core")) {
              sortTime = /* @__PURE__ */ new Date();
            }
            if (typeof textSorter === "object") {
              colMax = c.columns;
              while (colMax--) {
                tmp = ts.getColumnData(table, textSorter, colMax);
                if (typeof tmp === "function") {
                  sorter[colMax] = tmp;
                }
              }
            }
            for (tbodyIndex = 0; tbodyIndex < len; tbodyIndex++) {
              colMax = c.cache[tbodyIndex].colMax;
              rows = c.cache[tbodyIndex].normalized;
              rows.sort(function(a, b) {
                var sortIndex, num, col, order, sort, x, y;
                for (sortIndex = 0; sortIndex < sortLen; sortIndex++) {
                  col = sortList[sortIndex][0];
                  order = sortList[sortIndex][1];
                  dir = order === 0;
                  if (c.sortStable && a[col] === b[col] && sortLen === 1) {
                    return a[c.columns].order - b[c.columns].order;
                  }
                  num = /n/i.test(ts.getSortType(c.parsers, col));
                  if (num && c.strings[col]) {
                    if (typeof ts.string[c.strings[col]] === "boolean") {
                      num = (dir ? 1 : -1) * (ts.string[c.strings[col]] ? -1 : 1);
                    } else {
                      num = c.strings[col] ? ts.string[c.strings[col]] || 0 : 0;
                    }
                    sort = c.numberSorter ? c.numberSorter(a[col], b[col], dir, colMax[col], table) : ts["sortNumeric" + (dir ? "Asc" : "Desc")](a[col], b[col], num, colMax[col], col, c);
                  } else {
                    x = dir ? a : b;
                    y = dir ? b : a;
                    if (typeof textSorter === "function") {
                      sort = textSorter(x[col], y[col], dir, col, table);
                    } else if (typeof sorter[col] === "function") {
                      sort = sorter[col](x[col], y[col], dir, col, table);
                    } else {
                      sort = ts["sortNatural" + (dir ? "Asc" : "Desc")](a[col] || "", b[col] || "", col, c);
                    }
                  }
                  if (sort) {
                    return sort;
                  }
                }
                return a[c.columns].order - b[c.columns].order;
              });
            }
            if (ts.debug(c, "core")) {
              console.log("Applying sort " + sortList.toString() + ts.benchmark(sortTime));
            }
          },
          resortComplete: function(c, callback) {
            if (c.table.isUpdating) {
              c.$table.triggerHandler("updateComplete", c.table);
            }
            if ($.isFunction(callback)) {
              callback(c.table);
            }
          },
          checkResort: function(c, resort, callback) {
            var sortList = $.isArray(resort) ? resort : c.sortList, resrt = typeof resort === "undefined" ? c.resort : resort;
            if (resrt !== false && !c.serverSideSorting && !c.table.isProcessing) {
              if (sortList.length) {
                ts.sortOn(c, sortList, function() {
                  ts.resortComplete(c, callback);
                }, true);
              } else {
                ts.sortReset(c, function() {
                  ts.resortComplete(c, callback);
                  ts.applyWidget(c.table, false);
                });
              }
            } else {
              ts.resortComplete(c, callback);
              ts.applyWidget(c.table, false);
            }
          },
          sortOn: function(c, list, callback, init) {
            var indx, table = c.table;
            c.$table.triggerHandler("sortStart", table);
            for (indx = 0; indx < c.columns; indx++) {
              c.sortVars[indx].sortedBy = ts.isValueInArray(indx, list) > -1 ? "sorton" : "";
            }
            ts.updateHeaderSortCount(c, list);
            ts.setHeadersCss(c);
            if (c.delayInit && ts.isEmptyObject(c.cache)) {
              ts.buildCache(c);
            }
            c.$table.triggerHandler("sortBegin", table);
            ts.multisort(c);
            ts.appendCache(c, init);
            c.$table.triggerHandler("sortBeforeEnd", table);
            c.$table.triggerHandler("sortEnd", table);
            ts.applyWidget(table);
            if ($.isFunction(callback)) {
              callback(table);
            }
          },
          sortReset: function(c, callback) {
            c.sortList = [];
            var indx;
            for (indx = 0; indx < c.columns; indx++) {
              c.sortVars[indx].count = -1;
              c.sortVars[indx].sortedBy = "";
            }
            ts.setHeadersCss(c);
            ts.multisort(c);
            ts.appendCache(c);
            if ($.isFunction(callback)) {
              callback(c.table);
            }
          },
          getSortType: function(parsers, column) {
            return parsers && parsers[column] ? parsers[column].type || "" : "";
          },
          getOrder: function(val) {
            return /^d/i.test(val) || val === 1;
          },
          // Natural sort - https://github.com/overset/javascript-natural-sort (date sorting removed)
          sortNatural: function(a, b) {
            if (a === b) {
              return 0;
            }
            a = (a || "").toString();
            b = (b || "").toString();
            var aNum, bNum, aFloat, bFloat, indx, max, regex = ts.regex;
            if (regex.hex.test(b)) {
              aNum = parseInt(a.match(regex.hex), 16);
              bNum = parseInt(b.match(regex.hex), 16);
              if (aNum < bNum) {
                return -1;
              }
              if (aNum > bNum) {
                return 1;
              }
            }
            aNum = a.replace(regex.chunk, "\\0$1\\0").replace(regex.chunks, "").split("\\0");
            bNum = b.replace(regex.chunk, "\\0$1\\0").replace(regex.chunks, "").split("\\0");
            max = Math.max(aNum.length, bNum.length);
            for (indx = 0; indx < max; indx++) {
              aFloat = isNaN(aNum[indx]) ? aNum[indx] || 0 : parseFloat(aNum[indx]) || 0;
              bFloat = isNaN(bNum[indx]) ? bNum[indx] || 0 : parseFloat(bNum[indx]) || 0;
              if (isNaN(aFloat) !== isNaN(bFloat)) {
                return isNaN(aFloat) ? 1 : -1;
              }
              if (typeof aFloat !== typeof bFloat) {
                aFloat += "";
                bFloat += "";
              }
              if (aFloat < bFloat) {
                return -1;
              }
              if (aFloat > bFloat) {
                return 1;
              }
            }
            return 0;
          },
          sortNaturalAsc: function(a, b, col, c) {
            if (a === b) {
              return 0;
            }
            var empty = ts.string[c.empties[col] || c.emptyTo];
            if (a === "" && empty !== 0) {
              return typeof empty === "boolean" ? empty ? -1 : 1 : -empty || -1;
            }
            if (b === "" && empty !== 0) {
              return typeof empty === "boolean" ? empty ? 1 : -1 : empty || 1;
            }
            return ts.sortNatural(a, b);
          },
          sortNaturalDesc: function(a, b, col, c) {
            if (a === b) {
              return 0;
            }
            var empty = ts.string[c.empties[col] || c.emptyTo];
            if (a === "" && empty !== 0) {
              return typeof empty === "boolean" ? empty ? -1 : 1 : empty || 1;
            }
            if (b === "" && empty !== 0) {
              return typeof empty === "boolean" ? empty ? 1 : -1 : -empty || -1;
            }
            return ts.sortNatural(b, a);
          },
          // basic alphabetical sort
          sortText: function(a, b) {
            return a > b ? 1 : a < b ? -1 : 0;
          },
          // return text string value by adding up ascii value
          // so the text is somewhat sorted when using a digital sort
          // this is NOT an alphanumeric sort
          getTextValue: function(val, num, max) {
            if (max) {
              var indx, len = val ? val.length : 0, n = max + num;
              for (indx = 0; indx < len; indx++) {
                n += val.charCodeAt(indx);
              }
              return num * n;
            }
            return 0;
          },
          sortNumericAsc: function(a, b, num, max, col, c) {
            if (a === b) {
              return 0;
            }
            var empty = ts.string[c.empties[col] || c.emptyTo];
            if (a === "" && empty !== 0) {
              return typeof empty === "boolean" ? empty ? -1 : 1 : -empty || -1;
            }
            if (b === "" && empty !== 0) {
              return typeof empty === "boolean" ? empty ? 1 : -1 : empty || 1;
            }
            if (isNaN(a)) {
              a = ts.getTextValue(a, num, max);
            }
            if (isNaN(b)) {
              b = ts.getTextValue(b, num, max);
            }
            return a - b;
          },
          sortNumericDesc: function(a, b, num, max, col, c) {
            if (a === b) {
              return 0;
            }
            var empty = ts.string[c.empties[col] || c.emptyTo];
            if (a === "" && empty !== 0) {
              return typeof empty === "boolean" ? empty ? -1 : 1 : empty || 1;
            }
            if (b === "" && empty !== 0) {
              return typeof empty === "boolean" ? empty ? 1 : -1 : -empty || -1;
            }
            if (isNaN(a)) {
              a = ts.getTextValue(a, num, max);
            }
            if (isNaN(b)) {
              b = ts.getTextValue(b, num, max);
            }
            return b - a;
          },
          sortNumeric: function(a, b) {
            return a - b;
          },
          /*
                  
                           
                              
                    
          */
          addWidget: function(widget) {
            if (widget.id && !ts.isEmptyObject(ts.getWidgetById(widget.id))) {
              console.warn('"' + widget.id + '" widget was loaded more than once!');
            }
            ts.widgets[ts.widgets.length] = widget;
          },
          hasWidget: function($table, name) {
            $table = $($table);
            return $table.length && $table[0].config && $table[0].config.widgetInit[name] || false;
          },
          getWidgetById: function(name) {
            var indx, widget, len = ts.widgets.length;
            for (indx = 0; indx < len; indx++) {
              widget = ts.widgets[indx];
              if (widget && widget.id && widget.id.toLowerCase() === name.toLowerCase()) {
                return widget;
              }
            }
          },
          applyWidgetOptions: function(table) {
            var indx, widget, wo, c = table.config, len = c.widgets.length;
            if (len) {
              for (indx = 0; indx < len; indx++) {
                widget = ts.getWidgetById(c.widgets[indx]);
                if (widget && widget.options) {
                  wo = $.extend(true, {}, widget.options);
                  c.widgetOptions = $.extend(true, wo, c.widgetOptions);
                  $.extend(true, ts.defaults.widgetOptions, widget.options);
                }
              }
            }
          },
          addWidgetFromClass: function(table) {
            var len, indx, c = table.config, regex = "^" + c.widgetClass.replace(ts.regex.templateName, "(\\S+)+") + "$", widgetClass = new RegExp(regex, "g"), widgets = (table.className || "").split(ts.regex.spaces);
            if (widgets.length) {
              len = widgets.length;
              for (indx = 0; indx < len; indx++) {
                if (widgets[indx].match(widgetClass)) {
                  c.widgets[c.widgets.length] = widgets[indx].replace(widgetClass, "$1");
                }
              }
            }
          },
          applyWidgetId: function(table, id, init) {
            table = $(table)[0];
            var applied, time, name, c = table.config, wo = c.widgetOptions, debug = ts.debug(c, "core"), widget = ts.getWidgetById(id);
            if (widget) {
              name = widget.id;
              applied = false;
              if ($.inArray(name, c.widgets) < 0) {
                c.widgets[c.widgets.length] = name;
              }
              if (debug) {
                time = /* @__PURE__ */ new Date();
              }
              if (init || !c.widgetInit[name]) {
                c.widgetInit[name] = true;
                if (table.hasInitialized) {
                  ts.applyWidgetOptions(table);
                }
                if (typeof widget.init === "function") {
                  applied = true;
                  if (debug) {
                    console[console.group ? "group" : "log"]("Initializing " + name + " widget");
                  }
                  widget.init(table, widget, c, wo);
                }
              }
              if (!init && typeof widget.format === "function") {
                applied = true;
                if (debug) {
                  console[console.group ? "group" : "log"]("Updating " + name + " widget");
                }
                widget.format(table, c, wo, false);
              }
              if (debug) {
                if (applied) {
                  console.log("Completed " + (init ? "initializing " : "applying ") + name + " widget" + ts.benchmark(time));
                  if (console.groupEnd) {
                    console.groupEnd();
                  }
                }
              }
            }
          },
          applyWidget: function(table, init, callback) {
            table = $(table)[0];
            var indx, len, names, widget, time, c = table.config, debug = ts.debug(c, "core"), widgets = [];
            if (init !== false && table.hasInitialized && (table.isApplyingWidgets || table.isUpdating)) {
              return;
            }
            if (debug) {
              time = /* @__PURE__ */ new Date();
            }
            ts.addWidgetFromClass(table);
            clearTimeout(c.timerReady);
            if (c.widgets.length) {
              table.isApplyingWidgets = true;
              c.widgets = $.grep(c.widgets, function(val, index) {
                return $.inArray(val, c.widgets) === index;
              });
              names = c.widgets || [];
              len = names.length;
              for (indx = 0; indx < len; indx++) {
                widget = ts.getWidgetById(names[indx]);
                if (widget && widget.id) {
                  if (!widget.priority) {
                    widget.priority = 10;
                  }
                  widgets[indx] = widget;
                } else if (debug) {
                  console.warn('"' + names[indx] + '" was enabled, but the widget code has not been loaded!');
                }
              }
              widgets.sort(function(a, b) {
                return a.priority < b.priority ? -1 : a.priority === b.priority ? 0 : 1;
              });
              len = widgets.length;
              if (debug) {
                console[console.group ? "group" : "log"]("Start " + (init ? "initializing" : "applying") + " widgets");
              }
              for (indx = 0; indx < len; indx++) {
                widget = widgets[indx];
                if (widget && widget.id) {
                  ts.applyWidgetId(table, widget.id, init);
                }
              }
              if (debug && console.groupEnd) {
                console.groupEnd();
              }
            }
            c.timerReady = setTimeout(function() {
              table.isApplyingWidgets = false;
              $.data(table, "lastWidgetApplication", /* @__PURE__ */ new Date());
              c.$table.triggerHandler("tablesorter-ready");
              if (!init && typeof callback === "function") {
                callback(table);
              }
              if (debug) {
                widget = c.widgets.length;
                console.log("Completed " + (init === true ? "initializing " : "applying ") + widget + " widget" + (widget !== 1 ? "s" : "") + ts.benchmark(time));
              }
            }, 10);
          },
          removeWidget: function(table, name, refreshing) {
            table = $(table)[0];
            var index, widget, indx, len, c = table.config;
            if (name === true) {
              name = [];
              len = ts.widgets.length;
              for (indx = 0; indx < len; indx++) {
                widget = ts.widgets[indx];
                if (widget && widget.id) {
                  name[name.length] = widget.id;
                }
              }
            } else {
              name = ($.isArray(name) ? name.join(",") : name || "").toLowerCase().split(/[\s,]+/);
            }
            len = name.length;
            for (index = 0; index < len; index++) {
              widget = ts.getWidgetById(name[index]);
              indx = $.inArray(name[index], c.widgets);
              if (indx >= 0 && refreshing !== true) {
                c.widgets.splice(indx, 1);
              }
              if (widget && widget.remove) {
                if (ts.debug(c, "core")) {
                  console.log((refreshing ? "Refreshing" : "Removing") + ' "' + name[index] + '" widget');
                }
                widget.remove(table, c, c.widgetOptions, refreshing);
                c.widgetInit[name[index]] = false;
              }
            }
            c.$table.triggerHandler("widgetRemoveEnd", table);
          },
          refreshWidgets: function(table, doAll, dontapply) {
            table = $(table)[0];
            var indx, widget, c = table.config, curWidgets = c.widgets, widgets = ts.widgets, len = widgets.length, list = [], callback = function(table2) {
              $(table2).triggerHandler("refreshComplete");
            };
            for (indx = 0; indx < len; indx++) {
              widget = widgets[indx];
              if (widget && widget.id && (doAll || $.inArray(widget.id, curWidgets) < 0)) {
                list[list.length] = widget.id;
              }
            }
            ts.removeWidget(table, list.join(","), true);
            if (dontapply !== true) {
              ts.applyWidget(table, doAll || false, callback);
              if (doAll) {
                ts.applyWidget(table, false, callback);
              }
            } else {
              callback(table);
            }
          },
          /*
                        
                                  
                                     
                          
          */
          benchmark: function(diff) {
            return " (" + ((/* @__PURE__ */ new Date()).getTime() - diff.getTime()) + " ms)";
          },
          // deprecated ts.log
          log: function() {
            console.log(arguments);
          },
          debug: function(c, name) {
            return c && (c.debug === true || typeof c.debug === "string" && c.debug.indexOf(name) > -1);
          },
          // $.isEmptyObject from jQuery v1.4
          isEmptyObject: function(obj) {
            for (var name in obj) {
              return false;
            }
            return true;
          },
          isValueInArray: function(column, arry) {
            var indx, len = arry && arry.length || 0;
            for (indx = 0; indx < len; indx++) {
              if (arry[indx][0] === column) {
                return indx;
              }
            }
            return -1;
          },
          formatFloat: function(str, table) {
            if (typeof str !== "string" || str === "") {
              return str;
            }
            var num, usFormat = table && table.config ? table.config.usNumberFormat !== false : typeof table !== "undefined" ? table : true;
            if (usFormat) {
              str = str.replace(ts.regex.comma, "");
            } else {
              str = str.replace(ts.regex.digitNonUS, "").replace(ts.regex.comma, ".");
            }
            if (ts.regex.digitNegativeTest.test(str)) {
              str = str.replace(ts.regex.digitNegativeReplace, "-$1");
            }
            num = parseFloat(str);
            return isNaN(num) ? $.trim(str) : num;
          },
          isDigit: function(str) {
            return isNaN(str) ? ts.regex.digitTest.test(str.toString().replace(ts.regex.digitReplace, "")) : str !== "";
          },
          // computeTableHeaderCellIndexes from:
          // http://www.javascripttoolbox.com/lib/table/examples.php
          // http://www.javascripttoolbox.com/temp/table_cellindex.html
          computeColumnIndex: function($rows, c) {
            var i, j, k, l, cell, cells, rowIndex, rowSpan, colSpan, firstAvailCol, columns = c && c.columns || 0, matrix = [], matrixrow = new Array(columns);
            for (i = 0; i < $rows.length; i++) {
              cells = $rows[i].cells;
              for (j = 0; j < cells.length; j++) {
                cell = cells[j];
                rowIndex = i;
                rowSpan = cell.rowSpan || 1;
                colSpan = cell.colSpan || 1;
                if (typeof matrix[rowIndex] === "undefined") {
                  matrix[rowIndex] = [];
                }
                for (k = 0; k < matrix[rowIndex].length + 1; k++) {
                  if (typeof matrix[rowIndex][k] === "undefined") {
                    firstAvailCol = k;
                    break;
                  }
                }
                if (columns && cell.cellIndex === firstAvailCol) {
                } else if (cell.setAttribute) {
                  cell.setAttribute("data-column", firstAvailCol);
                } else {
                  $(cell).attr("data-column", firstAvailCol);
                }
                for (k = rowIndex; k < rowIndex + rowSpan; k++) {
                  if (typeof matrix[k] === "undefined") {
                    matrix[k] = [];
                  }
                  matrixrow = matrix[k];
                  for (l = firstAvailCol; l < firstAvailCol + colSpan; l++) {
                    matrixrow[l] = "x";
                  }
                }
              }
            }
            ts.checkColumnCount($rows, matrix, matrixrow.length);
            return matrixrow.length;
          },
          checkColumnCount: function($rows, matrix, columns) {
            var i, len, valid = true, cells = [];
            for (i = 0; i < matrix.length; i++) {
              if (matrix[i]) {
                len = matrix[i].length;
                if (matrix[i].length !== columns) {
                  valid = false;
                  break;
                }
              }
            }
            if (!valid) {
              $rows.each(function(indx, el) {
                var cell = el.parentElement.nodeName;
                if (cells.indexOf(cell) < 0) {
                  cells.push(cell);
                }
              });
              console.error(
                "Invalid or incorrect number of columns in the " + cells.join(" or ") + "; expected " + columns + ", but found " + len + " columns"
              );
            }
          },
          // automatically add a colgroup with col elements set to a percentage width
          fixColumnWidth: function(table) {
            table = $(table)[0];
            var overallWidth, percent, $tbodies, len, index, c = table.config, $colgroup = c.$table.children("colgroup");
            if ($colgroup.length && $colgroup.hasClass(ts.css.colgroup)) {
              $colgroup.remove();
            }
            if (c.widthFixed && c.$table.children("colgroup").length === 0) {
              $colgroup = $('<colgroup class="' + ts.css.colgroup + '">');
              overallWidth = c.$table.width();
              $tbodies = c.$tbodies.find("tr:first").children(":visible");
              len = $tbodies.length;
              for (index = 0; index < len; index++) {
                percent = parseInt($tbodies.eq(index).width() / overallWidth * 1e3, 10) / 10 + "%";
                $colgroup.append($("<col>").css("width", percent));
              }
              c.$table.prepend($colgroup);
            }
          },
          // get sorter, string, empty, etc options for each column from
          // jQuery data, metadata, header option or header class name ('sorter-false')
          // priority = jQuery data > meta > headers option > header class name
          getData: function(header, configHeader, key) {
            var meta, cl4ss, val = "", $header = $(header);
            if (!$header.length) {
              return "";
            }
            meta = $.metadata ? $header.metadata() : false;
            cl4ss = " " + ($header.attr("class") || "");
            if (typeof $header.data(key) !== "undefined" || typeof $header.data(key.toLowerCase()) !== "undefined") {
              val += $header.data(key) || $header.data(key.toLowerCase());
            } else if (meta && typeof meta[key] !== "undefined") {
              val += meta[key];
            } else if (configHeader && typeof configHeader[key] !== "undefined") {
              val += configHeader[key];
            } else if (cl4ss !== " " && cl4ss.match(" " + key + "-")) {
              val = cl4ss.match(new RegExp("\\s" + key + "-([\\w-]+)"))[1] || "";
            }
            return $.trim(val);
          },
          getColumnData: function(table, obj, indx, getCell, $headers) {
            if (typeof obj !== "object" || obj === null) {
              return obj;
            }
            table = $(table)[0];
            var $header, key, c = table.config, $cells = $headers || c.$headers, $cell = c.$headerIndexed && c.$headerIndexed[indx] || $cells.find('[data-column="' + indx + '"]:last');
            if (typeof obj[indx] !== "undefined") {
              return getCell ? obj[indx] : obj[$cells.index($cell)];
            }
            for (key in obj) {
              if (typeof key === "string") {
                $header = $cell.filter(key).add($cell.find(key));
                if ($header.length) {
                  return obj[key];
                }
              }
            }
            return;
          },
          // *** Process table ***
          // add processing indicator
          isProcessing: function($table, toggle, $headers) {
            $table = $($table);
            var c = $table[0].config, $header = $headers || $table.find("." + ts.css.header);
            if (toggle) {
              if (typeof $headers !== "undefined" && c.sortList.length > 0) {
                $header = $header.filter(function() {
                  return this.sortDisabled ? false : ts.isValueInArray(parseFloat($(this).attr("data-column")), c.sortList) >= 0;
                });
              }
              $table.add($header).addClass(ts.css.processing + " " + c.cssProcessing);
            } else {
              $table.add($header).removeClass(ts.css.processing + " " + c.cssProcessing);
            }
          },
          // detach tbody but save the position
          // don't use tbody because there are portions that look for a tbody index (updateCell)
          processTbody: function(table, $tb, getIt) {
            table = $(table)[0];
            if (getIt) {
              table.isProcessing = true;
              $tb.before('<colgroup class="tablesorter-savemyplace"/>');
              return $.fn.detach ? $tb.detach() : $tb.remove();
            }
            var holdr = $(table).find("colgroup.tablesorter-savemyplace");
            $tb.insertAfter(holdr);
            holdr.remove();
            table.isProcessing = false;
          },
          clearTableBody: function(table) {
            $(table)[0].config.$tbodies.children().detach();
          },
          // used when replacing accented characters during sorting
          characterEquivalents: {
            "a": "",
            // 
            "A": "",
            // 
            "c": "",
            // 
            "C": "",
            // 
            "e": "",
            // 
            "E": "",
            // 
            "i": "",
            // 
            "I": "",
            // 
            "o": "",
            // 
            "O": "",
            // 
            "ss": "",
            //  (s sharp)
            "SS": "",
            //  (Capital sharp s)
            "u": "",
            // 
            "U": ""
            // 
          },
          replaceAccents: function(str) {
            var chr, acc = "[", eq = ts.characterEquivalents;
            if (!ts.characterRegex) {
              ts.characterRegexArray = {};
              for (chr in eq) {
                if (typeof chr === "string") {
                  acc += eq[chr];
                  ts.characterRegexArray[chr] = new RegExp("[" + eq[chr] + "]", "g");
                }
              }
              ts.characterRegex = new RegExp(acc + "]");
            }
            if (ts.characterRegex.test(str)) {
              for (chr in eq) {
                if (typeof chr === "string") {
                  str = str.replace(ts.characterRegexArray[chr], chr);
                }
              }
            }
            return str;
          },
          validateOptions: function(c) {
            var setting, setting2, typ, timer, ignore = "headers sortForce sortList sortAppend widgets".split(" "), orig = c.originalSettings;
            if (orig) {
              if (ts.debug(c, "core")) {
                timer = /* @__PURE__ */ new Date();
              }
              for (setting in orig) {
                typ = typeof ts.defaults[setting];
                if (typ === "undefined") {
                  console.warn('Tablesorter Warning! "table.config.' + setting + '" option not recognized');
                } else if (typ === "object") {
                  for (setting2 in orig[setting]) {
                    typ = ts.defaults[setting] && typeof ts.defaults[setting][setting2];
                    if ($.inArray(setting, ignore) < 0 && typ === "undefined") {
                      console.warn('Tablesorter Warning! "table.config.' + setting + "." + setting2 + '" option not recognized');
                    }
                  }
                }
              }
              if (ts.debug(c, "core")) {
                console.log("validate options time:" + ts.benchmark(timer));
              }
            }
          },
          // restore headers
          restoreHeaders: function(table) {
            var index, $cell, c = $(table)[0].config, $headers = c.$table.find(c.selectorHeaders), len = $headers.length;
            for (index = 0; index < len; index++) {
              $cell = $headers.eq(index);
              if ($cell.find("." + ts.css.headerIn).length) {
                $cell.html(c.headerContent[index]);
              }
            }
          },
          destroy: function(table, removeClasses, callback) {
            table = $(table)[0];
            if (!table.hasInitialized) {
              return;
            }
            ts.removeWidget(table, true, false);
            var events, $t = $(table), c = table.config, $h = $t.find("thead:first"), $r = $h.find("tr." + ts.css.headerRow).removeClass(ts.css.headerRow + " " + c.cssHeaderRow), $f = $t.find("tfoot:first > tr").children("th, td");
            if (removeClasses === false && $.inArray("uitheme", c.widgets) >= 0) {
              $t.triggerHandler("applyWidgetId", ["uitheme"]);
              $t.triggerHandler("applyWidgetId", ["zebra"]);
            }
            $h.find("tr").not($r).remove();
            events = "sortReset update updateRows updateAll updateHeaders updateCell addRows updateComplete sorton appendCache updateCache applyWidgetId applyWidgets refreshWidgets removeWidget destroy mouseup mouseleave " + "keypress sortBegin sortEnd resetToLoadState ".split(" ").join(c.namespace + " ");
            $t.removeData("tablesorter").unbind(events.replace(ts.regex.spaces, " "));
            c.$headers.add($f).removeClass([ts.css.header, c.cssHeader, c.cssAsc, c.cssDesc, ts.css.sortAsc, ts.css.sortDesc, ts.css.sortNone].join(" ")).removeAttr("data-column").removeAttr("aria-label").attr("aria-disabled", "true");
            $r.find(c.selectorSort).unbind("mousedown mouseup keypress ".split(" ").join(c.namespace + " ").replace(ts.regex.spaces, " "));
            ts.restoreHeaders(table);
            $t.toggleClass(ts.css.table + " " + c.tableClass + " tablesorter-" + c.theme, removeClasses === false);
            $t.removeClass(c.namespace.slice(1));
            table.hasInitialized = false;
            delete table.config.cache;
            if (typeof callback === "function") {
              callback(table);
            }
            if (ts.debug(c, "core")) {
              console.log("tablesorter has been removed");
            }
          }
        };
        $.fn.tablesorter = function(settings) {
          return this.each(function() {
            var table = this, c = $.extend(true, {}, ts.defaults, settings, ts.instanceMethods);
            c.originalSettings = settings;
            if (!table.hasInitialized && ts.buildTable && this.nodeName !== "TABLE") {
              ts.buildTable(table, c);
            } else {
              ts.setup(table, c);
            }
          });
        };
        if (!(window.console && window.console.log)) {
          ts.logs = [];
          console = {};
          console.log = console.warn = console.error = console.table = function() {
            var arg = arguments.length > 1 ? arguments : arguments[0];
            ts.logs[ts.logs.length] = { date: Date.now(), log: arg };
          };
        }
        ts.addParser({
          id: "no-parser",
          is: function() {
            return false;
          },
          format: function() {
            return "";
          },
          type: "text"
        });
        ts.addParser({
          id: "text",
          is: function() {
            return true;
          },
          format: function(str, table) {
            var c = table.config;
            if (str) {
              str = $.trim(c.ignoreCase ? str.toLocaleLowerCase() : str);
              str = c.sortLocaleCompare ? ts.replaceAccents(str) : str;
            }
            return str;
          },
          type: "text"
        });
        ts.regex.nondigit = /[^\w,. \-()]/g;
        ts.addParser({
          id: "digit",
          is: function(str) {
            return ts.isDigit(str);
          },
          format: function(str, table) {
            var num = ts.formatFloat((str || "").replace(ts.regex.nondigit, ""), table);
            return str && typeof num === "number" ? num : str ? $.trim(str && table.config.ignoreCase ? str.toLocaleLowerCase() : str) : str;
          },
          type: "numeric"
        });
        ts.regex.currencyReplace = /[+\-,. ]/g;
        ts.regex.currencyTest = /^\(?\d+[\u00a3$\u20ac\u00a4\u00a5\u00a2?.]|[\u00a3$\u20ac\u00a4\u00a5\u00a2?.]\d+\)?$/;
        ts.addParser({
          id: "currency",
          is: function(str) {
            str = (str || "").replace(ts.regex.currencyReplace, "");
            return ts.regex.currencyTest.test(str);
          },
          format: function(str, table) {
            var num = ts.formatFloat((str || "").replace(ts.regex.nondigit, ""), table);
            return str && typeof num === "number" ? num : str ? $.trim(str && table.config.ignoreCase ? str.toLocaleLowerCase() : str) : str;
          },
          type: "numeric"
        });
        ts.regex.urlProtocolTest = /^(https?|ftp|file):\/\//;
        ts.regex.urlProtocolReplace = /(https?|ftp|file):\/\/(www\.)?/;
        ts.addParser({
          id: "url",
          is: function(str) {
            return ts.regex.urlProtocolTest.test(str);
          },
          format: function(str) {
            return str ? $.trim(str.replace(ts.regex.urlProtocolReplace, "")) : str;
          },
          type: "text"
        });
        ts.regex.dash = /-/g;
        ts.regex.isoDate = /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}/;
        ts.addParser({
          id: "isoDate",
          is: function(str) {
            return ts.regex.isoDate.test(str);
          },
          format: function(str) {
            var date = str ? new Date(str.replace(ts.regex.dash, "/")) : str;
            return date instanceof Date && isFinite(date) ? date.getTime() : str;
          },
          type: "numeric"
        });
        ts.regex.percent = /%/g;
        ts.regex.percentTest = /(\d\s*?%|%\s*?\d)/;
        ts.addParser({
          id: "percent",
          is: function(str) {
            return ts.regex.percentTest.test(str) && str.length < 15;
          },
          format: function(str, table) {
            return str ? ts.formatFloat(str.replace(ts.regex.percent, ""), table) : str;
          },
          type: "numeric"
        });
        ts.addParser({
          id: "image",
          is: function(str, table, node, $node) {
            return $node.find("img").length > 0;
          },
          format: function(str, table, cell) {
            return $(cell).find("img").attr(table.config.imgAttr || "alt") || str;
          },
          parsed: true,
          // filter widget flag
          type: "text"
        });
        ts.regex.dateReplace = /(\S)([AP]M)$/i;
        ts.regex.usLongDateTest1 = /^[A-Z]{3,10}\.?\s+\d{1,2},?\s+(\d{4})(\s+\d{1,2}:\d{2}(:\d{2})?(\s+[AP]M)?)?$/i;
        ts.regex.usLongDateTest2 = /^\d{1,2}\s+[A-Z]{3,10}\s+\d{4}/i;
        ts.addParser({
          id: "usLongDate",
          is: function(str) {
            return ts.regex.usLongDateTest1.test(str) || ts.regex.usLongDateTest2.test(str);
          },
          format: function(str) {
            var date = str ? new Date(str.replace(ts.regex.dateReplace, "$1 $2")) : str;
            return date instanceof Date && isFinite(date) ? date.getTime() : str;
          },
          type: "numeric"
        });
        ts.regex.shortDateTest = /(^\d{1,2}[\/\s]\d{1,2}[\/\s]\d{4})|(^\d{4}[\/\s]\d{1,2}[\/\s]\d{1,2})/;
        ts.regex.shortDateReplace = /[\-.,]/g;
        ts.regex.shortDateXXY = /(\d{1,2})[\/\s](\d{1,2})[\/\s](\d{4})/;
        ts.regex.shortDateYMD = /(\d{4})[\/\s](\d{1,2})[\/\s](\d{1,2})/;
        ts.convertFormat = function(dateString, format) {
          dateString = (dateString || "").replace(ts.regex.spaces, " ").replace(ts.regex.shortDateReplace, "/");
          if (format === "mmddyyyy") {
            dateString = dateString.replace(ts.regex.shortDateXXY, "$3/$1/$2");
          } else if (format === "ddmmyyyy") {
            dateString = dateString.replace(ts.regex.shortDateXXY, "$3/$2/$1");
          } else if (format === "yyyymmdd") {
            dateString = dateString.replace(ts.regex.shortDateYMD, "$1/$2/$3");
          }
          var date = new Date(dateString);
          return date instanceof Date && isFinite(date) ? date.getTime() : "";
        };
        ts.addParser({
          id: "shortDate",
          // 'mmddyyyy', 'ddmmyyyy' or 'yyyymmdd'
          is: function(str) {
            str = (str || "").replace(ts.regex.spaces, " ").replace(ts.regex.shortDateReplace, "/");
            return ts.regex.shortDateTest.test(str);
          },
          format: function(str, table, cell, cellIndex) {
            if (str) {
              var c = table.config, $header = c.$headerIndexed[cellIndex], format = $header.length && $header.data("dateFormat") || ts.getData($header, ts.getColumnData(table, c.headers, cellIndex), "dateFormat") || c.dateFormat;
              if ($header.length) {
                $header.data("dateFormat", format);
              }
              return ts.convertFormat(str, format) || str;
            }
            return str;
          },
          type: "numeric"
        });
        ts.regex.timeTest = /^(0?[1-9]|1[0-2]):([0-5]\d)(\s[AP]M)$|^((?:[01]\d|[2][0-4]):[0-5]\d)$/i;
        ts.regex.timeMatch = /(0?[1-9]|1[0-2]):([0-5]\d)(\s[AP]M)|((?:[01]\d|[2][0-4]):[0-5]\d)/i;
        ts.addParser({
          id: "time",
          is: function(str) {
            return ts.regex.timeTest.test(str);
          },
          format: function(str) {
            var temp, timePart = (str || "").match(ts.regex.timeMatch), orig = new Date(str), time = str && (timePart !== null ? timePart[0] : "00:00 AM"), date = time ? /* @__PURE__ */ new Date("2000/01/01 " + time.replace(ts.regex.dateReplace, "$1 $2")) : time;
            if (date instanceof Date && isFinite(date)) {
              temp = orig instanceof Date && isFinite(orig) ? orig.getTime() : 0;
              return temp ? parseFloat(date.getTime() + "." + orig.getTime()) : date.getTime();
            }
            return str;
          },
          type: "numeric"
        });
        ts.addParser({
          id: "metadata",
          is: function() {
            return false;
          },
          format: function(str, table, cell) {
            var c = table.config, p = !c.parserMetadataName ? "sortValue" : c.parserMetadataName;
            return $(cell).metadata()[p];
          },
          type: "numeric"
        });
        ts.addWidget({
          id: "zebra",
          priority: 90,
          format: function(table, c, wo) {
            var $visibleRows, $row, count, isEven, tbodyIndex, rowIndex, len, child = new RegExp(c.cssChildRow, "i"), $tbodies = c.$tbodies.add($(c.namespace + "_extra_table").children("tbody:not(." + c.cssInfoBlock + ")"));
            for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++) {
              count = 0;
              $visibleRows = $tbodies.eq(tbodyIndex).children("tr:visible").not(c.selectorRemove);
              len = $visibleRows.length;
              for (rowIndex = 0; rowIndex < len; rowIndex++) {
                $row = $visibleRows.eq(rowIndex);
                if (!child.test($row[0].className)) {
                  count++;
                }
                isEven = count % 2 === 0;
                $row.removeClass(wo.zebra[isEven ? 1 : 0]).addClass(wo.zebra[isEven ? 0 : 1]);
              }
            }
          },
          remove: function(table, c, wo, refreshing) {
            if (refreshing) {
              return;
            }
            var tbodyIndex, $tbody, $tbodies = c.$tbodies, toRemove = (wo.zebra || ["even", "odd"]).join(" ");
            for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++) {
              $tbody = ts.processTbody(table, $tbodies.eq(tbodyIndex), true);
              $tbody.children().removeClass(toRemove);
              ts.processTbody(table, $tbody, false);
            }
          }
        });
      })(jQuery2);
      ;
      (function($, window2, document2) {
        "use strict";
        var ts = $.tablesorter || {};
        $.extend(true, ts.defaults, {
          fixedUrl: "",
          widgetOptions: {
            storage_fixedUrl: "",
            storage_group: "",
            storage_page: "",
            storage_storageType: "",
            storage_tableId: "",
            storage_useSessionStorage: ""
          }
        });
        ts.storage = function(table, key, value, options) {
          table = $(table)[0];
          var cookieIndex, cookies, date, hasStorage = false, values = {}, c = table.config, wo = c && c.widgetOptions, debug = ts.debug(c, "storage"), storageType = (options && options.storageType || wo && wo.storage_storageType).toString().charAt(0).toLowerCase(), session = storageType ? "" : options && options.useSessionStorage || wo && wo.storage_useSessionStorage, $table = $(table), id = options && options.id || $table.attr(options && options.group || wo && wo.storage_group || "data-table-group") || wo && wo.storage_tableId || table.id || $(".tablesorter").index($table), url = options && options.url || $table.attr(options && options.page || wo && wo.storage_page || "data-table-page") || wo && wo.storage_fixedUrl || c && c.fixedUrl || window2.location.pathname;
          if (storageType !== "c") {
            storageType = storageType === "s" || session ? "sessionStorage" : "localStorage";
            if (storageType in window2) {
              try {
                window2[storageType].setItem("_tmptest", "temp");
                hasStorage = true;
                window2[storageType].removeItem("_tmptest");
              } catch (error) {
                console.warn(storageType + " is not supported in this browser");
              }
            }
          }
          if (debug) {
            console.log("Storage >> Using", hasStorage ? storageType : "cookies");
          }
          if ($.parseJSON) {
            if (hasStorage) {
              values = $.parseJSON(window2[storageType][key] || "null") || {};
            } else {
              cookies = document2.cookie.split(/[;\s|=]/);
              cookieIndex = $.inArray(key, cookies) + 1;
              values = cookieIndex !== 0 ? $.parseJSON(cookies[cookieIndex] || "null") || {} : {};
            }
          }
          if (typeof value !== "undefined" && window2.JSON && JSON.hasOwnProperty("stringify")) {
            if (!values[url]) {
              values[url] = {};
            }
            values[url][id] = value;
            if (hasStorage) {
              window2[storageType][key] = JSON.stringify(values);
            } else {
              date = /* @__PURE__ */ new Date();
              date.setTime(date.getTime() + 31536e6);
              document2.cookie = key + "=" + JSON.stringify(values).replace(/\"/g, '"') + "; expires=" + date.toGMTString() + "; path=/";
            }
          } else {
            return values && values[url] ? values[url][id] : "";
          }
        };
      })(jQuery2, window, document);
      ;
      (function($) {
        "use strict";
        var ts = $.tablesorter || {};
        ts.themes = {
          "bootstrap": {
            table: "table table-bordered table-striped",
            caption: "caption",
            // header class names
            header: "bootstrap-header",
            // give the header a gradient background (theme.bootstrap_2.css)
            sortNone: "",
            sortAsc: "",
            sortDesc: "",
            active: "",
            // applied when column is sorted
            hover: "",
            // custom css required - a defined bootstrap style may not override other classes
            // icon class names
            icons: "",
            // add 'bootstrap-icon-white' to make them white; this icon class is added to the <i> in the header
            iconSortNone: "bootstrap-icon-unsorted",
            // class name added to icon when column is not sorted
            iconSortAsc: "glyphicon glyphicon-chevron-up",
            // class name added to icon when column has ascending sort
            iconSortDesc: "glyphicon glyphicon-chevron-down",
            // class name added to icon when column has descending sort
            filterRow: "",
            // filter row class
            footerRow: "",
            footerCells: "",
            even: "",
            // even row zebra striping
            odd: ""
            // odd row zebra striping
          },
          "jui": {
            table: "ui-widget ui-widget-content ui-corner-all",
            // table classes
            caption: "ui-widget-content",
            // header class names
            header: "ui-widget-header ui-corner-all ui-state-default",
            // header classes
            sortNone: "",
            sortAsc: "",
            sortDesc: "",
            active: "ui-state-active",
            // applied when column is sorted
            hover: "ui-state-hover",
            // hover class
            // icon class names
            icons: "ui-icon",
            // icon class added to the <i> in the header
            iconSortNone: "ui-icon-carat-2-n-s ui-icon-caret-2-n-s",
            // class name added to icon when column is not sorted
            iconSortAsc: "ui-icon-carat-1-n ui-icon-caret-1-n",
            // class name added to icon when column has ascending sort
            iconSortDesc: "ui-icon-carat-1-s ui-icon-caret-1-s",
            // class name added to icon when column has descending sort
            filterRow: "",
            footerRow: "",
            footerCells: "",
            even: "ui-widget-content",
            // even row zebra striping
            odd: "ui-state-default"
            // odd row zebra striping
          }
        };
        $.extend(ts.css, {
          wrapper: "tablesorter-wrapper"
          // ui theme & resizable
        });
        ts.addWidget({
          id: "uitheme",
          priority: 10,
          format: function(table, c, wo) {
            var i, tmp, hdr, icon, time, $header, $icon, $tfoot, $h, oldtheme, oldremove, oldIconRmv, hasOldTheme, themesAll = ts.themes, $table = c.$table.add($(c.namespace + "_extra_table")), $headers = c.$headers.add($(c.namespace + "_extra_headers")), theme = c.theme || "jui", themes = themesAll[theme] || {}, remove = $.trim([themes.sortNone, themes.sortDesc, themes.sortAsc, themes.active].join(" ")), iconRmv = $.trim([themes.iconSortNone, themes.iconSortDesc, themes.iconSortAsc].join(" ")), debug = ts.debug(c, "uitheme");
            if (debug) {
              time = /* @__PURE__ */ new Date();
            }
            if (!$table.hasClass("tablesorter-" + theme) || c.theme !== c.appliedTheme || !wo.uitheme_applied) {
              wo.uitheme_applied = true;
              oldtheme = themesAll[c.appliedTheme] || {};
              hasOldTheme = !$.isEmptyObject(oldtheme);
              oldremove = hasOldTheme ? [oldtheme.sortNone, oldtheme.sortDesc, oldtheme.sortAsc, oldtheme.active].join(" ") : "";
              oldIconRmv = hasOldTheme ? [oldtheme.iconSortNone, oldtheme.iconSortDesc, oldtheme.iconSortAsc].join(" ") : "";
              if (hasOldTheme) {
                wo.zebra[0] = $.trim(" " + wo.zebra[0].replace(" " + oldtheme.even, ""));
                wo.zebra[1] = $.trim(" " + wo.zebra[1].replace(" " + oldtheme.odd, ""));
                c.$tbodies.children().removeClass([oldtheme.even, oldtheme.odd].join(" "));
              }
              if (themes.even) {
                wo.zebra[0] += " " + themes.even;
              }
              if (themes.odd) {
                wo.zebra[1] += " " + themes.odd;
              }
              $table.children("caption").removeClass(oldtheme.caption || "").addClass(themes.caption);
              $tfoot = $table.removeClass((c.appliedTheme ? "tablesorter-" + (c.appliedTheme || "") : "") + " " + (oldtheme.table || "")).addClass("tablesorter-" + theme + " " + (themes.table || "")).children("tfoot");
              c.appliedTheme = c.theme;
              if ($tfoot.length) {
                $tfoot.children("tr").removeClass(oldtheme.footerRow || "").addClass(themes.footerRow).children("th, td").removeClass(oldtheme.footerCells || "").addClass(themes.footerCells);
              }
              $headers.removeClass((hasOldTheme ? [oldtheme.header, oldtheme.hover, oldremove].join(" ") : "") || "").addClass(themes.header).not(".sorter-false").unbind("mouseenter.tsuitheme mouseleave.tsuitheme").bind("mouseenter.tsuitheme mouseleave.tsuitheme", function(event) {
                $(this)[event.type === "mouseenter" ? "addClass" : "removeClass"](themes.hover || "");
              });
              $headers.each(function() {
                var $this = $(this);
                if (!$this.find("." + ts.css.wrapper).length) {
                  $this.wrapInner('<div class="' + ts.css.wrapper + '" style="position:relative;height:100%;width:100%"></div>');
                }
              });
              if (c.cssIcon) {
                $headers.find("." + ts.css.icon).removeClass(hasOldTheme ? [oldtheme.icons, oldIconRmv].join(" ") : "").addClass(themes.icons || "");
              }
              if (ts.hasWidget(c.table, "filter")) {
                tmp = function() {
                  $table.children("thead").children("." + ts.css.filterRow).removeClass(hasOldTheme ? oldtheme.filterRow || "" : "").addClass(themes.filterRow || "");
                };
                if (wo.filter_initialized) {
                  tmp();
                } else {
                  $table.one("filterInit", function() {
                    tmp();
                  });
                }
              }
            }
            for (i = 0; i < c.columns; i++) {
              $header = c.$headers.add($(c.namespace + "_extra_headers")).not(".sorter-false").filter('[data-column="' + i + '"]');
              $icon = ts.css.icon ? $header.find("." + ts.css.icon) : $();
              $h = $headers.not(".sorter-false").filter('[data-column="' + i + '"]:last');
              if ($h.length) {
                $header.removeClass(remove);
                $icon.removeClass(iconRmv);
                if ($h[0].sortDisabled) {
                  $icon.removeClass(themes.icons || "");
                } else {
                  hdr = themes.sortNone;
                  icon = themes.iconSortNone;
                  if ($h.hasClass(ts.css.sortAsc)) {
                    hdr = [themes.sortAsc, themes.active].join(" ");
                    icon = themes.iconSortAsc;
                  } else if ($h.hasClass(ts.css.sortDesc)) {
                    hdr = [themes.sortDesc, themes.active].join(" ");
                    icon = themes.iconSortDesc;
                  }
                  $header.addClass(hdr);
                  $icon.addClass(icon || "");
                }
              }
            }
            if (debug) {
              console.log("uitheme >> Applied " + theme + " theme" + ts.benchmark(time));
            }
          },
          remove: function(table, c, wo, refreshing) {
            if (!wo.uitheme_applied) {
              return;
            }
            var $table = c.$table, theme = c.appliedTheme || "jui", themes = ts.themes[theme] || ts.themes.jui, $headers = $table.children("thead").children(), remove = themes.sortNone + " " + themes.sortDesc + " " + themes.sortAsc, iconRmv = themes.iconSortNone + " " + themes.iconSortDesc + " " + themes.iconSortAsc;
            $table.removeClass("tablesorter-" + theme + " " + themes.table);
            wo.uitheme_applied = false;
            if (refreshing) {
              return;
            }
            $table.find(ts.css.header).removeClass(themes.header);
            $headers.unbind("mouseenter.tsuitheme mouseleave.tsuitheme").removeClass(themes.hover + " " + remove + " " + themes.active).filter("." + ts.css.filterRow).removeClass(themes.filterRow);
            $headers.find("." + ts.css.icon).removeClass(themes.icons + " " + iconRmv);
          }
        });
      })(jQuery2);
      ;
      (function($) {
        "use strict";
        var ts = $.tablesorter || {};
        ts.addWidget({
          id: "columns",
          priority: 65,
          options: {
            columns: ["primary", "secondary", "tertiary"]
          },
          format: function(table, c, wo) {
            var $tbody, tbodyIndex, $rows, rows, $row, $cells, remove, indx, $table = c.$table, $tbodies = c.$tbodies, sortList = c.sortList, len = sortList.length, css = wo && wo.columns || ["primary", "secondary", "tertiary"], last = css.length - 1;
            remove = css.join(" ");
            for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++) {
              $tbody = ts.processTbody(table, $tbodies.eq(tbodyIndex), true);
              $rows = $tbody.children("tr");
              $rows.each(function() {
                $row = $(this);
                if (this.style.display !== "none") {
                  $cells = $row.children().removeClass(remove);
                  if (sortList && sortList[0]) {
                    $cells.eq(sortList[0][0]).addClass(css[0]);
                    if (len > 1) {
                      for (indx = 1; indx < len; indx++) {
                        $cells.eq(sortList[indx][0]).addClass(css[indx] || css[last]);
                      }
                    }
                  }
                }
              });
              ts.processTbody(table, $tbody, false);
            }
            rows = wo.columns_thead !== false ? ["thead tr"] : [];
            if (wo.columns_tfoot !== false) {
              rows.push("tfoot tr");
            }
            if (rows.length) {
              $rows = $table.find(rows.join(",")).children().removeClass(remove);
              if (len) {
                for (indx = 0; indx < len; indx++) {
                  $rows.filter('[data-column="' + sortList[indx][0] + '"]').addClass(css[indx] || css[last]);
                }
              }
            }
          },
          remove: function(table, c, wo) {
            var tbodyIndex, $tbody, $tbodies = c.$tbodies, remove = (wo.columns || ["primary", "secondary", "tertiary"]).join(" ");
            c.$headers.removeClass(remove);
            c.$table.children("tfoot").children("tr").children("th, td").removeClass(remove);
            for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++) {
              $tbody = ts.processTbody(table, $tbodies.eq(tbodyIndex), true);
              $tbody.children("tr").each(function() {
                $(this).children().removeClass(remove);
              });
              ts.processTbody(table, $tbody, false);
            }
          }
        });
      })(jQuery2);
      ;
      (function($) {
        "use strict";
        var tsf, tsfRegex, ts = $.tablesorter || {}, tscss = ts.css, tskeyCodes = ts.keyCodes;
        $.extend(tscss, {
          filterRow: "tablesorter-filter-row",
          filter: "tablesorter-filter",
          filterDisabled: "disabled",
          filterRowHide: "hideme"
        });
        $.extend(tskeyCodes, {
          backSpace: 8,
          escape: 27,
          space: 32,
          left: 37,
          down: 40
        });
        ts.addWidget({
          id: "filter",
          priority: 50,
          options: {
            filter_cellFilter: "",
            // css class name added to the filter cell ( string or array )
            filter_childRows: false,
            // if true, filter includes child row content in the search
            filter_childByColumn: false,
            // ( filter_childRows must be true ) if true = search child rows by column; false = search all child row text grouped
            filter_childWithSibs: true,
            // if true, include matching child row siblings
            filter_columnAnyMatch: true,
            // if true, allows using '#:{query}' in AnyMatch searches ( column:query )
            filter_columnFilters: true,
            // if true, a filter will be added to the top of each table column
            filter_cssFilter: "",
            // css class name added to the filter row & each input in the row ( tablesorter-filter is ALWAYS added )
            filter_defaultAttrib: "data-value",
            // data attribute in the header cell that contains the default filter value
            filter_defaultFilter: {},
            // add a default column filter type '~{query}' to make fuzzy searches default; '{q1} AND {q2}' to make all searches use a logical AND.
            filter_excludeFilter: {},
            // filters to exclude, per column
            filter_external: "",
            // jQuery selector string ( or jQuery object ) of external filters
            filter_filteredRow: "filtered",
            // class added to filtered rows; define in css with "display:none" to hide the filtered-out rows
            filter_filterLabel: 'Filter "{{label}}" column by...',
            // Aria-label added to filter input/select; see #1495
            filter_formatter: null,
            // add custom filter elements to the filter row
            filter_functions: null,
            // add custom filter functions using this option
            filter_hideEmpty: true,
            // hide filter row when table is empty
            filter_hideFilters: false,
            // collapse filter row when mouse leaves the area
            filter_ignoreCase: true,
            // if true, make all searches case-insensitive
            filter_liveSearch: true,
            // if true, search column content while the user types ( with a delay )
            filter_matchType: { "input": "exact", "select": "exact" },
            // global query settings ('exact' or 'match'); overridden by "filter-match" or "filter-exact" class
            filter_onlyAvail: "filter-onlyAvail",
            // a header with a select dropdown & this class name will only show available ( visible ) options within the drop down
            filter_placeholder: { search: "", select: "" },
            // default placeholder text ( overridden by any header 'data-placeholder' setting )
            filter_reset: null,
            // jQuery selector string of an element used to reset the filters
            filter_resetOnEsc: true,
            // Reset filter input when the user presses escape - normalized across browsers
            filter_saveFilters: false,
            // Use the $.tablesorter.storage utility to save the most recent filters
            filter_searchDelay: 300,
            // typing delay in milliseconds before starting a search
            filter_searchFiltered: true,
            // allow searching through already filtered rows in special circumstances; will speed up searching in large tables if true
            filter_selectSource: null,
            // include a function to return an array of values to be added to the column filter select
            filter_selectSourceSeparator: "|",
            // filter_selectSource array text left of the separator is added to the option value, right into the option text
            filter_serversideFiltering: false,
            // if true, must perform server-side filtering b/c client-side filtering is disabled, but the ui and events will still be used.
            filter_startsWith: false,
            // if true, filter start from the beginning of the cell contents
            filter_useParsedData: false
            // filter all data using parsed content
          },
          format: function(table, c, wo) {
            if (!c.$table.hasClass("hasFilters")) {
              tsf.init(table, c, wo);
            }
          },
          remove: function(table, c, wo, refreshing) {
            var tbodyIndex, $tbody, $table = c.$table, $tbodies = c.$tbodies, events = "addRows updateCell update updateRows updateComplete appendCache filterReset filterAndSortReset filterFomatterUpdate filterEnd search stickyHeadersInit ".split(" ").join(c.namespace + "filter ");
            $table.removeClass("hasFilters").unbind(events.replace(ts.regex.spaces, " ")).find("." + tscss.filterRow).remove();
            wo.filter_initialized = false;
            if (refreshing) {
              return;
            }
            for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++) {
              $tbody = ts.processTbody(table, $tbodies.eq(tbodyIndex), true);
              $tbody.children().removeClass(wo.filter_filteredRow).show();
              ts.processTbody(table, $tbody, false);
            }
            if (wo.filter_reset) {
              $(document).undelegate(wo.filter_reset, "click" + c.namespace + "filter");
            }
          }
        });
        tsf = ts.filter = {
          // regex used in filter 'check' functions - not for general use and not documented
          regex: {
            regex: /^\/((?:\\\/|[^\/])+)\/([migyu]{0,5})?$/,
            // regex to test for regex
            child: /tablesorter-childRow/,
            // child row class name; this gets updated in the script
            filtered: /filtered/,
            // filtered (hidden) row class name; updated in the script
            type: /undefined|number/,
            // check type
            exact: /(^[\"\'=]+)|([\"\'=]+$)/g,
            // exact match (allow '==')
            operators: /[<>=]/g,
            // replace operators
            query: "(q|query)",
            // replace filter queries
            wild01: /\?/g,
            // wild card match 0 or 1
            wild0More: /\*/g,
            // wild care match 0 or more
            quote: /\"/g,
            isNeg1: /(>=?\s*-\d)/,
            isNeg2: /(<=?\s*\d)/
          },
          // function( c, data ) { }
          // c = table.config
          // data.$row = jQuery object of the row currently being processed
          // data.$cells = jQuery object of all cells within the current row
          // data.filters = array of filters for all columns ( some may be undefined )
          // data.filter = filter for the current column
          // data.iFilter = same as data.filter, except lowercase ( if wo.filter_ignoreCase is true )
          // data.exact = table cell text ( or parsed data if column parser enabled; may be a number & not a string )
          // data.iExact = same as data.exact, except lowercase ( if wo.filter_ignoreCase is true; may be a number & not a string )
          // data.cache = table cell text from cache, so it has been parsed ( & in all lower case if c.ignoreCase is true )
          // data.cacheArray = An array of parsed content from each table cell in the row being processed
          // data.index = column index; table = table element ( DOM )
          // data.parsed = array ( by column ) of boolean values ( from filter_useParsedData or 'filter-parsed' class )
          types: {
            or: function(c, data, vars) {
              if ((tsfRegex.orTest.test(data.iFilter) || tsfRegex.orSplit.test(data.filter)) && // this test for regex has potential to slow down the overall search
              !tsfRegex.regex.test(data.filter)) {
                var indx, filterMatched, query, regex, data2 = $.extend({}, data), filter = data.filter.split(tsfRegex.orSplit), iFilter = data.iFilter.split(tsfRegex.orSplit), len = filter.length;
                for (indx = 0; indx < len; indx++) {
                  data2.nestedFilters = true;
                  data2.filter = "" + (tsf.parseFilter(c, filter[indx], data) || "");
                  data2.iFilter = "" + (tsf.parseFilter(c, iFilter[indx], data) || "");
                  query = "(" + (tsf.parseFilter(c, data2.filter, data) || "") + ")";
                  try {
                    regex = new RegExp(data.isMatch ? query : "^" + query + "$", c.widgetOptions.filter_ignoreCase ? "i" : "");
                    filterMatched = regex.test(data2.exact) || tsf.processTypes(c, data2, vars);
                    if (filterMatched) {
                      return filterMatched;
                    }
                  } catch (error) {
                    return null;
                  }
                }
                return filterMatched || false;
              }
              return null;
            },
            // Look for an AND or && operator ( logical and )
            and: function(c, data, vars) {
              if (tsfRegex.andTest.test(data.filter)) {
                var indx, filterMatched, result, query, regex, data2 = $.extend({}, data), filter = data.filter.split(tsfRegex.andSplit), iFilter = data.iFilter.split(tsfRegex.andSplit), len = filter.length;
                for (indx = 0; indx < len; indx++) {
                  data2.nestedFilters = true;
                  data2.filter = "" + (tsf.parseFilter(c, filter[indx], data) || "");
                  data2.iFilter = "" + (tsf.parseFilter(c, iFilter[indx], data) || "");
                  query = ("(" + (tsf.parseFilter(c, data2.filter, data) || "") + ")").replace(tsfRegex.wild01, "\\S{1}").replace(tsfRegex.wild0More, "\\S*");
                  try {
                    regex = new RegExp(data.isMatch ? query : "^" + query + "$", c.widgetOptions.filter_ignoreCase ? "i" : "");
                    result = regex.test(data2.exact) || tsf.processTypes(c, data2, vars);
                    if (indx === 0) {
                      filterMatched = result;
                    } else {
                      filterMatched = filterMatched && result;
                    }
                  } catch (error) {
                    return null;
                  }
                }
                return filterMatched || false;
              }
              return null;
            },
            // Look for regex
            regex: function(c, data) {
              if (tsfRegex.regex.test(data.filter)) {
                var matches, regex = data.filter_regexCache[data.index] || tsfRegex.regex.exec(data.filter), isRegex = regex instanceof RegExp;
                try {
                  if (!isRegex) {
                    data.filter_regexCache[data.index] = regex = new RegExp(regex[1], regex[2]);
                  }
                  matches = regex.test(data.exact);
                } catch (error) {
                  matches = false;
                }
                return matches;
              }
              return null;
            },
            // Look for operators >, >=, < or <=
            operators: function(c, data) {
              if (tsfRegex.operTest.test(data.iFilter) && data.iExact !== "") {
                var cachedValue, result, txt, table = c.table, parsed = data.parsed[data.index], query = ts.formatFloat(data.iFilter.replace(tsfRegex.operators, ""), table), parser = c.parsers[data.index] || {}, savedSearch = query;
                if (parsed || parser.type === "numeric") {
                  txt = $.trim("" + data.iFilter.replace(tsfRegex.operators, ""));
                  result = tsf.parseFilter(c, txt, data, true);
                  query = typeof result === "number" && result !== "" && !isNaN(result) ? result : query;
                }
                if ((parsed || parser.type === "numeric") && !isNaN(query) && typeof data.cache !== "undefined") {
                  cachedValue = data.cache;
                } else {
                  txt = isNaN(data.iExact) ? data.iExact.replace(ts.regex.nondigit, "") : data.iExact;
                  cachedValue = ts.formatFloat(txt, table);
                }
                if (tsfRegex.gtTest.test(data.iFilter)) {
                  result = tsfRegex.gteTest.test(data.iFilter) ? cachedValue >= query : cachedValue > query;
                } else if (tsfRegex.ltTest.test(data.iFilter)) {
                  result = tsfRegex.lteTest.test(data.iFilter) ? cachedValue <= query : cachedValue < query;
                }
                if (!result && savedSearch === "") {
                  result = true;
                }
                return result;
              }
              return null;
            },
            // Look for a not match
            notMatch: function(c, data) {
              if (tsfRegex.notTest.test(data.iFilter)) {
                var indx, txt = data.iFilter.replace("!", ""), filter = tsf.parseFilter(c, txt, data) || "";
                if (tsfRegex.exact.test(filter)) {
                  filter = filter.replace(tsfRegex.exact, "");
                  return filter === "" ? true : $.trim(filter) !== data.iExact;
                } else {
                  indx = data.iExact.search($.trim(filter));
                  return filter === "" ? true : (
                    // return true if not found
                    data.anyMatch ? indx < 0 : (
                      // return false if found
                      !(c.widgetOptions.filter_startsWith ? indx === 0 : indx >= 0)
                    )
                  );
                }
              }
              return null;
            },
            // Look for quotes or equals to get an exact match; ignore type since iExact could be numeric
            exact: function(c, data) {
              if (tsfRegex.exact.test(data.iFilter)) {
                var txt = data.iFilter.replace(tsfRegex.exact, ""), filter = tsf.parseFilter(c, txt, data) || "";
                return data.anyMatch ? $.inArray(filter, data.rowArray) >= 0 : filter == data.iExact;
              }
              return null;
            },
            // Look for a range ( using ' to ' or ' - ' ) - see issue #166; thanks matzhu!
            range: function(c, data) {
              if (tsfRegex.toTest.test(data.iFilter)) {
                var result, tmp, range1, range2, table = c.table, index = data.index, parsed = data.parsed[index], query = data.iFilter.split(tsfRegex.toSplit);
                tmp = query[0].replace(ts.regex.nondigit, "") || "";
                range1 = ts.formatFloat(tsf.parseFilter(c, tmp, data), table);
                tmp = query[1].replace(ts.regex.nondigit, "") || "";
                range2 = ts.formatFloat(tsf.parseFilter(c, tmp, data), table);
                if (parsed || c.parsers[index].type === "numeric") {
                  result = c.parsers[index].format("" + query[0], table, c.$headers.eq(index), index);
                  range1 = result !== "" && !isNaN(result) ? result : range1;
                  result = c.parsers[index].format("" + query[1], table, c.$headers.eq(index), index);
                  range2 = result !== "" && !isNaN(result) ? result : range2;
                }
                if ((parsed || c.parsers[index].type === "numeric") && !isNaN(range1) && !isNaN(range2)) {
                  result = data.cache;
                } else {
                  tmp = isNaN(data.iExact) ? data.iExact.replace(ts.regex.nondigit, "") : data.iExact;
                  result = ts.formatFloat(tmp, table);
                }
                if (range1 > range2) {
                  tmp = range1;
                  range1 = range2;
                  range2 = tmp;
                }
                return result >= range1 && result <= range2 || (range1 === "" || range2 === "");
              }
              return null;
            },
            // Look for wild card: ? = single, * = multiple, or | = logical OR
            wild: function(c, data) {
              if (tsfRegex.wildOrTest.test(data.iFilter)) {
                var query = "" + (tsf.parseFilter(c, data.iFilter, data) || "");
                if (!tsfRegex.wildTest.test(query) && data.nestedFilters) {
                  query = data.isMatch ? query : "^(" + query + ")$";
                }
                try {
                  return new RegExp(
                    query.replace(tsfRegex.wild01, "\\S{1}").replace(tsfRegex.wild0More, "\\S*"),
                    c.widgetOptions.filter_ignoreCase ? "i" : ""
                  ).test(data.exact);
                } catch (error) {
                  return null;
                }
              }
              return null;
            },
            // fuzzy text search; modified from https://github.com/mattyork/fuzzy ( MIT license )
            fuzzy: function(c, data) {
              if (tsfRegex.fuzzyTest.test(data.iFilter)) {
                var indx, patternIndx = 0, len = data.iExact.length, txt = data.iFilter.slice(1), pattern = tsf.parseFilter(c, txt, data) || "";
                for (indx = 0; indx < len; indx++) {
                  if (data.iExact[indx] === pattern[patternIndx]) {
                    patternIndx += 1;
                  }
                }
                return patternIndx === pattern.length;
              }
              return null;
            }
          },
          init: function(table) {
            ts.language = $.extend(true, {}, {
              to: "to",
              or: "or",
              and: "and"
            }, ts.language);
            var options, string, txt, $header, column, val, fxn, noSelect, c = table.config, wo = c.widgetOptions, processStr = function(prefix, str, suffix) {
              str = str.trim();
              return str === "" ? "" : (prefix || "") + str + (suffix || "");
            };
            c.$table.addClass("hasFilters");
            c.lastSearch = [];
            wo.filter_searchTimer = null;
            wo.filter_initTimer = null;
            wo.filter_formatterCount = 0;
            wo.filter_formatterInit = [];
            wo.filter_anyColumnSelector = '[data-column="all"],[data-column="any"]';
            wo.filter_multipleColumnSelector = '[data-column*="-"],[data-column*=","]';
            val = "\\{" + tsfRegex.query + "\\}";
            $.extend(tsfRegex, {
              child: new RegExp(c.cssChildRow),
              filtered: new RegExp(wo.filter_filteredRow),
              alreadyFiltered: new RegExp("(\\s+(-" + processStr("|", ts.language.or) + processStr("|", ts.language.to) + ")\\s+)", "i"),
              toTest: new RegExp("\\s+(-" + processStr("|", ts.language.to) + ")\\s+", "i"),
              toSplit: new RegExp("(?:\\s+(?:-" + processStr("|", ts.language.to) + ")\\s+)", "gi"),
              andTest: new RegExp("\\s+(" + processStr("", ts.language.and, "|") + "&&)\\s+", "i"),
              andSplit: new RegExp("(?:\\s+(?:" + processStr("", ts.language.and, "|") + "&&)\\s+)", "gi"),
              orTest: new RegExp("(\\|" + processStr("|\\s+", ts.language.or, "\\s+") + ")", "i"),
              orSplit: new RegExp("(?:\\|" + processStr("|\\s+(?:", ts.language.or, ")\\s+") + ")", "gi"),
              iQuery: new RegExp(val, "i"),
              igQuery: new RegExp(val, "ig"),
              operTest: /^[<>]=?/,
              gtTest: />/,
              gteTest: />=/,
              ltTest: /</,
              lteTest: /<=/,
              notTest: /^\!/,
              wildOrTest: /[\?\*\|]/,
              wildTest: /\?\*/,
              fuzzyTest: /^~/,
              exactTest: /[=\"\|!]/
            });
            val = c.$headers.filter(".filter-false, .parser-false").length;
            if (wo.filter_columnFilters !== false && val !== c.$headers.length) {
              tsf.buildRow(table, c, wo);
            }
            txt = "addRows updateCell update updateRows updateComplete appendCache filterReset " + "filterAndSortReset filterResetSaved filterEnd search ".split(" ").join(c.namespace + "filter ");
            c.$table.bind(txt, function(event, filter) {
              val = wo.filter_hideEmpty && $.isEmptyObject(c.cache) && !(c.delayInit && event.type === "appendCache");
              c.$table.find("." + tscss.filterRow).toggleClass(wo.filter_filteredRow, val);
              if (!/(search|filter)/.test(event.type)) {
                event.stopPropagation();
                tsf.buildDefault(table, true);
              }
              if (event.type === "filterReset" || event.type === "filterAndSortReset") {
                c.$table.find("." + tscss.filter).add(wo.filter_$externalFilters).val("");
                if (event.type === "filterAndSortReset") {
                  ts.sortReset(this.config, function() {
                    tsf.searching(table, []);
                  });
                } else {
                  tsf.searching(table, []);
                }
              } else if (event.type === "filterResetSaved") {
                ts.storage(table, "tablesorter-filters", "");
              } else if (event.type === "filterEnd") {
                tsf.buildDefault(table, true);
              } else {
                filter = event.type === "search" ? filter : event.type === "updateComplete" ? c.$table.data("lastSearch") : "";
                if (/(update|add)/.test(event.type) && event.type !== "updateComplete") {
                  c.lastCombinedFilter = null;
                  c.lastSearch = [];
                  setTimeout(function() {
                    c.$table.triggerHandler("filterFomatterUpdate");
                  }, 100);
                }
                tsf.searching(table, filter, true);
              }
              return false;
            });
            if (wo.filter_reset) {
              if (wo.filter_reset instanceof $) {
                wo.filter_reset.click(function() {
                  c.$table.triggerHandler("filterReset");
                });
              } else if ($(wo.filter_reset).length) {
                $(document).undelegate(wo.filter_reset, "click" + c.namespace + "filter").delegate(wo.filter_reset, "click" + c.namespace + "filter", function() {
                  c.$table.triggerHandler("filterReset");
                });
              }
            }
            if (wo.filter_functions) {
              for (column = 0; column < c.columns; column++) {
                fxn = ts.getColumnData(table, wo.filter_functions, column);
                if (fxn) {
                  $header = c.$headerIndexed[column].removeClass("filter-select");
                  noSelect = !($header.hasClass("filter-false") || $header.hasClass("parser-false"));
                  options = "";
                  if (fxn === true && noSelect) {
                    tsf.buildSelect(table, column);
                  } else if (typeof fxn === "object" && noSelect) {
                    for (string in fxn) {
                      if (typeof string === "string") {
                        options += options === "" ? '<option value="">' + ($header.data("placeholder") || $header.attr("data-placeholder") || wo.filter_placeholder.select || "") + "</option>" : "";
                        val = string;
                        txt = string;
                        if (string.indexOf(wo.filter_selectSourceSeparator) >= 0) {
                          val = string.split(wo.filter_selectSourceSeparator);
                          txt = val[1];
                          val = val[0];
                        }
                        options += "<option " + (txt === val ? "" : 'data-function-name="' + string + '" ') + 'value="' + val + '">' + txt + "</option>";
                      }
                    }
                    c.$table.find("thead").find("select." + tscss.filter + '[data-column="' + column + '"]').append(options);
                    txt = wo.filter_selectSource;
                    fxn = typeof txt === "function" ? true : ts.getColumnData(table, txt, column);
                    if (fxn) {
                      tsf.buildSelect(c.table, column, "", true, $header.hasClass(wo.filter_onlyAvail));
                    }
                  }
                }
              }
            }
            tsf.buildDefault(table, true);
            tsf.bindSearch(table, c.$table.find("." + tscss.filter), true);
            if (wo.filter_external) {
              tsf.bindSearch(table, wo.filter_external);
            }
            if (wo.filter_hideFilters) {
              tsf.hideFilters(c);
            }
            if (c.showProcessing) {
              txt = "filterStart filterEnd ".split(" ").join(c.namespace + "filter-sp ");
              c.$table.unbind(txt.replace(ts.regex.spaces, " ")).bind(txt, function(event, columns) {
                $header = columns ? c.$table.find("." + tscss.header).filter("[data-column]").filter(function() {
                  return columns[$(this).data("column")] !== "";
                }) : "";
                ts.isProcessing(table, event.type === "filterStart", columns ? $header : "");
              });
            }
            c.filteredRows = c.totalRows;
            txt = "tablesorter-initialized pagerBeforeInitialized ".split(" ").join(c.namespace + "filter ");
            c.$table.unbind(txt.replace(ts.regex.spaces, " ")).bind(txt, function() {
              tsf.completeInit(this);
            });
            if (c.pager && c.pager.initialized && !wo.filter_initialized) {
              c.$table.triggerHandler("filterFomatterUpdate");
              setTimeout(function() {
                tsf.filterInitComplete(c);
              }, 100);
            } else if (!wo.filter_initialized) {
              tsf.completeInit(table);
            }
          },
          completeInit: function(table) {
            var c = table.config, wo = c.widgetOptions, filters = tsf.setDefaults(table, c, wo) || [];
            if (filters.length) {
              if (!(c.delayInit && filters.join("") === "")) {
                ts.setFilters(table, filters, true);
              }
            }
            c.$table.triggerHandler("filterFomatterUpdate");
            setTimeout(function() {
              if (!wo.filter_initialized) {
                tsf.filterInitComplete(c);
              }
            }, 100);
          },
          // $cell parameter, but not the config, is passed to the filter_formatters,
          // so we have to work with it instead
          formatterUpdated: function($cell, column) {
            var $table = $cell && $cell.closest("table");
            var config = $table.length && $table[0].config, wo = config && config.widgetOptions;
            if (wo && !wo.filter_initialized) {
              wo.filter_formatterInit[column] = 1;
            }
          },
          filterInitComplete: function(c) {
            var indx, len, wo = c.widgetOptions, count = 0, completed = function() {
              wo.filter_initialized = true;
              c.lastSearch = c.$table.data("lastSearch");
              c.$table.triggerHandler("filterInit", c);
              tsf.findRows(c.table, c.lastSearch || []);
              if (ts.debug(c, "filter")) {
                console.log("Filter >> Widget initialized");
              }
            };
            if ($.isEmptyObject(wo.filter_formatter)) {
              completed();
            } else {
              len = wo.filter_formatterInit.length;
              for (indx = 0; indx < len; indx++) {
                if (wo.filter_formatterInit[indx] === 1) {
                  count++;
                }
              }
              clearTimeout(wo.filter_initTimer);
              if (!wo.filter_initialized && count === wo.filter_formatterCount) {
                completed();
              } else if (!wo.filter_initialized) {
                wo.filter_initTimer = setTimeout(function() {
                  completed();
                }, 500);
              }
            }
          },
          // encode or decode filters for storage; see #1026
          processFilters: function(filters, encode) {
            var indx, result = [], mode = encode ? encodeURIComponent : decodeURIComponent, len = filters.length;
            for (indx = 0; indx < len; indx++) {
              if (filters[indx]) {
                result[indx] = mode(filters[indx]);
              }
            }
            return result;
          },
          setDefaults: function(table, c, wo) {
            var isArray, saved, indx, col, $filters, filters = ts.getFilters(table) || [];
            if (wo.filter_saveFilters && ts.storage) {
              saved = ts.storage(table, "tablesorter-filters") || [];
              isArray = $.isArray(saved);
              if (!(isArray && saved.join("") === "" || !isArray)) {
                filters = tsf.processFilters(saved);
              }
            }
            if (filters.join("") === "") {
              $filters = c.$headers.add(wo.filter_$externalFilters).filter("[" + wo.filter_defaultAttrib + "]");
              for (indx = 0; indx <= c.columns; indx++) {
                col = indx === c.columns ? "all" : indx;
                filters[indx] = $filters.filter('[data-column="' + col + '"]').attr(wo.filter_defaultAttrib) || filters[indx] || "";
              }
            }
            c.$table.data("lastSearch", filters);
            return filters;
          },
          parseFilter: function(c, filter, data, parsed) {
            return parsed || data.parsed[data.index] ? c.parsers[data.index].format(filter, c.table, [], data.index) : filter;
          },
          buildRow: function(table, c, wo) {
            var $filter, col, column, $header, makeSelect, disabled, name, ffxn, tmp, cellFilter = wo.filter_cellFilter, columns = c.columns, arry = $.isArray(cellFilter), buildFilter = '<tr role="search" class="' + tscss.filterRow + " " + c.cssIgnoreRow + '">';
            for (column = 0; column < columns; column++) {
              if (c.$headerIndexed[column].length) {
                tmp = c.$headerIndexed[column] && c.$headerIndexed[column][0].colSpan || 0;
                if (tmp > 1) {
                  buildFilter += '<td data-column="' + column + "-" + (column + tmp - 1) + '" colspan="' + tmp + '"';
                } else {
                  buildFilter += '<td data-column="' + column + '"';
                }
                if (arry) {
                  buildFilter += cellFilter[column] ? ' class="' + cellFilter[column] + '"' : "";
                } else {
                  buildFilter += cellFilter !== "" ? ' class="' + cellFilter + '"' : "";
                }
                buildFilter += "></td>";
              }
            }
            c.$filters = $(buildFilter += "</tr>").appendTo(c.$table.children("thead").eq(0)).children("td");
            for (column = 0; column < columns; column++) {
              disabled = false;
              $header = c.$headerIndexed[column];
              if ($header && $header.length) {
                $filter = tsf.getColumnElm(c, c.$filters, column);
                ffxn = ts.getColumnData(table, wo.filter_functions, column);
                makeSelect = wo.filter_functions && ffxn && typeof ffxn !== "function" || $header.hasClass("filter-select");
                col = ts.getColumnData(table, c.headers, column);
                disabled = ts.getData($header[0], col, "filter") === "false" || ts.getData($header[0], col, "parser") === "false";
                if (makeSelect) {
                  buildFilter = $("<select>").appendTo($filter);
                } else {
                  ffxn = ts.getColumnData(table, wo.filter_formatter, column);
                  if (ffxn) {
                    wo.filter_formatterCount++;
                    buildFilter = ffxn($filter, column);
                    if (buildFilter && buildFilter.length === 0) {
                      buildFilter = $filter.children("input");
                    }
                    if (buildFilter && (buildFilter.parent().length === 0 || buildFilter.parent().length && buildFilter.parent()[0] !== $filter[0])) {
                      $filter.append(buildFilter);
                    }
                  } else {
                    buildFilter = $('<input type="search">').appendTo($filter);
                  }
                  if (buildFilter) {
                    tmp = $header.data("placeholder") || $header.attr("data-placeholder") || wo.filter_placeholder.search || "";
                    buildFilter.attr("placeholder", tmp);
                  }
                }
                if (buildFilter) {
                  name = ($.isArray(wo.filter_cssFilter) ? typeof wo.filter_cssFilter[column] !== "undefined" ? wo.filter_cssFilter[column] || "" : "" : wo.filter_cssFilter) || "";
                  buildFilter.addClass(tscss.filter + " " + name);
                  name = wo.filter_filterLabel;
                  tmp = name.match(/{{([^}]+?)}}/g);
                  if (!tmp) {
                    tmp = ["{{label}}"];
                  }
                  $.each(tmp, function(indx, attr) {
                    var regex = new RegExp(attr, "g"), data = $header.attr("data-" + attr.replace(/{{|}}/g, "")), text = typeof data === "undefined" ? $header.text() : data;
                    name = name.replace(regex, $.trim(text));
                  });
                  buildFilter.attr({
                    "data-column": $filter.attr("data-column"),
                    "aria-label": name
                  });
                  if (disabled) {
                    buildFilter.attr("placeholder", "").addClass(tscss.filterDisabled)[0].disabled = true;
                  }
                }
              }
            }
          },
          bindSearch: function(table, $el, internal) {
            table = $(table)[0];
            $el = $($el);
            if (!$el.length) {
              return;
            }
            var tmp, c = table.config, wo = c.widgetOptions, namespace = c.namespace + "filter", $ext = wo.filter_$externalFilters;
            if (internal !== true) {
              tmp = wo.filter_anyColumnSelector + "," + wo.filter_multipleColumnSelector;
              wo.filter_$anyMatch = $el.filter(tmp);
              if ($ext && $ext.length) {
                wo.filter_$externalFilters = wo.filter_$externalFilters.add($el);
              } else {
                wo.filter_$externalFilters = $el;
              }
              ts.setFilters(table, c.$table.data("lastSearch") || [], internal === false);
            }
            tmp = "keypress keyup keydown search change input ".split(" ").join(namespace + " ");
            $el.attr("data-lastSearchTime", (/* @__PURE__ */ new Date()).getTime()).unbind(tmp.replace(ts.regex.spaces, " ")).bind("keydown" + namespace, function(event) {
              if (event.which === tskeyCodes.escape && !table.config.widgetOptions.filter_resetOnEsc) {
                return false;
              }
            }).bind("keyup" + namespace, function(event) {
              wo = table.config.widgetOptions;
              var column = parseInt($(this).attr("data-column"), 10), liveSearch = typeof wo.filter_liveSearch === "boolean" ? wo.filter_liveSearch : ts.getColumnData(table, wo.filter_liveSearch, column);
              if (typeof liveSearch === "undefined") {
                liveSearch = wo.filter_liveSearch.fallback || false;
              }
              $(this).attr("data-lastSearchTime", (/* @__PURE__ */ new Date()).getTime());
              if (event.which === tskeyCodes.escape) {
                this.value = wo.filter_resetOnEsc ? "" : c.lastSearch[column];
              } else if (this.value !== "" && // liveSearch can contain a min value length; ignore arrow and meta keys, but allow backspace
              (typeof liveSearch === "number" && this.value.length < liveSearch || // let return & backspace continue on, but ignore arrows & non-valid characters
              event.which !== tskeyCodes.enter && event.which !== tskeyCodes.backSpace && (event.which < tskeyCodes.space || event.which >= tskeyCodes.left && event.which <= tskeyCodes.down))) {
                return;
              } else if (liveSearch === false) {
                if (this.value !== "" && event.which !== tskeyCodes.enter) {
                  return;
                }
              }
              tsf.searching(table, true, true, column);
            }).bind("search change keypress input blur ".split(" ").join(namespace + " "), function(event) {
              var column = parseInt($(this).attr("data-column"), 10), eventType = event.type, liveSearch = typeof wo.filter_liveSearch === "boolean" ? wo.filter_liveSearch : ts.getColumnData(table, wo.filter_liveSearch, column);
              if (table.config.widgetOptions.filter_initialized && // immediate search if user presses enter
              (event.which === tskeyCodes.enter || // immediate search if a "search" or "blur" is triggered on the input
              (eventType === "search" || eventType === "blur") || // change & input events must be ignored if liveSearch !== true
              (eventType === "change" || eventType === "input") && // prevent search if liveSearch is a number
              (liveSearch === true || liveSearch !== true && event.target.nodeName !== "INPUT") && // don't allow 'change' or 'input' event to process if the input value
              // is the same - fixes #685
              this.value !== c.lastSearch[column])) {
                event.preventDefault();
                $(this).attr("data-lastSearchTime", (/* @__PURE__ */ new Date()).getTime());
                tsf.searching(table, eventType !== "keypress" || event.which === tskeyCodes.enter, true, column);
              }
            });
          },
          searching: function(table, filter, skipFirst, column) {
            var liveSearch, wo = table.config.widgetOptions;
            if (typeof column === "undefined") {
              liveSearch = false;
            } else {
              liveSearch = typeof wo.filter_liveSearch === "boolean" ? wo.filter_liveSearch : (
                // get column setting, or set to fallback value, or default to false
                ts.getColumnData(table, wo.filter_liveSearch, column)
              );
              if (typeof liveSearch === "undefined") {
                liveSearch = wo.filter_liveSearch.fallback || false;
              }
            }
            clearTimeout(wo.filter_searchTimer);
            if (typeof filter === "undefined" || filter === true) {
              wo.filter_searchTimer = setTimeout(function() {
                tsf.checkFilters(table, filter, skipFirst);
              }, liveSearch ? wo.filter_searchDelay : 10);
            } else {
              tsf.checkFilters(table, filter, skipFirst);
            }
          },
          equalFilters: function(c, filter1, filter2) {
            var indx, f1 = [], f2 = [], len = c.columns + 1;
            filter1 = $.isArray(filter1) ? filter1 : [];
            filter2 = $.isArray(filter2) ? filter2 : [];
            for (indx = 0; indx < len; indx++) {
              f1[indx] = filter1[indx] || "";
              f2[indx] = filter2[indx] || "";
            }
            return f1.join(",") === f2.join(",");
          },
          checkFilters: function(table, filter, skipFirst) {
            var c = table.config, wo = c.widgetOptions, filterArray = $.isArray(filter), filters = filterArray ? filter : ts.getFilters(table, true), currentFilters = filters || [];
            if ($.isEmptyObject(c.cache)) {
              if (c.delayInit && (!c.pager || c.pager && c.pager.initialized)) {
                ts.updateCache(c, function() {
                  tsf.checkFilters(table, false, skipFirst);
                });
              }
              return;
            }
            if (filterArray) {
              ts.setFilters(table, filters, false, skipFirst !== true);
              if (!wo.filter_initialized) {
                c.lastSearch = [];
                c.lastCombinedFilter = "";
              }
            }
            if (wo.filter_hideFilters) {
              c.$table.find("." + tscss.filterRow).triggerHandler(tsf.hideFiltersCheck(c) ? "mouseleave" : "mouseenter");
            }
            if (tsf.equalFilters(c, c.lastSearch, currentFilters)) {
              if (filter !== false) {
                return;
              } else {
                c.lastCombinedFilter = "";
                c.lastSearch = [];
              }
            }
            filters = filters || [];
            filters = Array.prototype.map ? filters.map(String) : (
              // for IE8 & older browsers - maybe not the best method
              filters.join("").split("")
            );
            if (wo.filter_initialized) {
              c.$table.triggerHandler("filterStart", [filters]);
            }
            if (c.showProcessing) {
              setTimeout(function() {
                tsf.findRows(table, filters, currentFilters);
                return false;
              }, 30);
            } else {
              tsf.findRows(table, filters, currentFilters);
              return false;
            }
          },
          hideFiltersCheck: function(c) {
            if (typeof c.widgetOptions.filter_hideFilters === "function") {
              var val = c.widgetOptions.filter_hideFilters(c);
              if (typeof val === "boolean") {
                return val;
              }
            }
            return ts.getFilters(c.$table).join("") === "";
          },
          hideFilters: function(c, $table) {
            var timer;
            ($table || c.$table).find("." + tscss.filterRow).addClass(tscss.filterRowHide).bind("mouseenter mouseleave", function(e) {
              var event = e, $row = $(this);
              clearTimeout(timer);
              timer = setTimeout(function() {
                if (/enter|over/.test(event.type)) {
                  $row.removeClass(tscss.filterRowHide);
                } else {
                  if ($(document.activeElement).closest("tr")[0] !== $row[0]) {
                    $row.toggleClass(tscss.filterRowHide, tsf.hideFiltersCheck(c));
                  }
                }
              }, 200);
            }).find("input, select").bind("focus blur", function(e) {
              var event = e, $row = $(this).closest("tr");
              clearTimeout(timer);
              timer = setTimeout(function() {
                clearTimeout(timer);
                $row.toggleClass(tscss.filterRowHide, tsf.hideFiltersCheck(c) && event.type !== "focus");
              }, 200);
            });
          },
          defaultFilter: function(filter, mask) {
            if (filter === "") {
              return filter;
            }
            var regex = tsfRegex.iQuery, maskLen = mask.match(tsfRegex.igQuery).length, query = maskLen > 1 ? $.trim(filter).split(/\s/) : [$.trim(filter)], len = query.length - 1, indx = 0, val = mask;
            if (len < 1 && maskLen > 1) {
              query[1] = query[0];
            }
            while (regex.test(val)) {
              val = val.replace(regex, query[indx++] || "");
              if (regex.test(val) && indx < len && (query[indx] || "") !== "") {
                val = mask.replace(regex, val);
              }
            }
            return val;
          },
          getLatestSearch: function($input) {
            if ($input) {
              return $input.sort(function(a, b) {
                return $(b).attr("data-lastSearchTime") - $(a).attr("data-lastSearchTime");
              });
            }
            return $input || $();
          },
          findRange: function(c, val, ignoreRanges) {
            var temp, ranges, range, start, end, singles, i, indx, len, columns = [];
            if (/^[0-9]+$/.test(val)) {
              return [parseInt(val, 10)];
            }
            if (!ignoreRanges && /-/.test(val)) {
              ranges = val.match(/(\d+)\s*-\s*(\d+)/g);
              len = ranges ? ranges.length : 0;
              for (indx = 0; indx < len; indx++) {
                range = ranges[indx].split(/\s*-\s*/);
                start = parseInt(range[0], 10) || 0;
                end = parseInt(range[1], 10) || c.columns - 1;
                if (start > end) {
                  temp = start;
                  start = end;
                  end = temp;
                }
                if (end >= c.columns) {
                  end = c.columns - 1;
                }
                for (; start <= end; start++) {
                  columns[columns.length] = start;
                }
                val = val.replace(ranges[indx], "");
              }
            }
            if (!ignoreRanges && /,/.test(val)) {
              singles = val.split(/\s*,\s*/);
              len = singles.length;
              for (i = 0; i < len; i++) {
                if (singles[i] !== "") {
                  indx = parseInt(singles[i], 10);
                  if (indx < c.columns) {
                    columns[columns.length] = indx;
                  }
                }
              }
            }
            if (!columns.length) {
              for (indx = 0; indx < c.columns; indx++) {
                columns[columns.length] = indx;
              }
            }
            return columns;
          },
          getColumnElm: function(c, $elements, column) {
            return $elements.filter(function() {
              var cols = tsf.findRange(c, $(this).attr("data-column"));
              return $.inArray(column, cols) > -1;
            });
          },
          multipleColumns: function(c, $input) {
            var wo = c.widgetOptions, targets = wo.filter_initialized || !$input.filter(wo.filter_anyColumnSelector).length, val = $.trim(tsf.getLatestSearch($input).attr("data-column") || "");
            return tsf.findRange(c, val, !targets);
          },
          processTypes: function(c, data, vars) {
            var ffxn, filterMatched = null, matches = null;
            for (ffxn in tsf.types) {
              if ($.inArray(ffxn, vars.excludeMatch) < 0 && matches === null) {
                matches = tsf.types[ffxn](c, data, vars);
                if (matches !== null) {
                  data.matchedOn = ffxn;
                  filterMatched = matches;
                }
              }
            }
            return filterMatched;
          },
          matchType: function(c, columnIndex) {
            var isMatch, wo = c.widgetOptions, $el = c.$headerIndexed[columnIndex];
            if ($el.hasClass("filter-exact")) {
              isMatch = false;
            } else if ($el.hasClass("filter-match")) {
              isMatch = true;
            } else {
              if (wo.filter_columnFilters) {
                $el = c.$filters.find("." + tscss.filter).add(wo.filter_$externalFilters).filter('[data-column="' + columnIndex + '"]');
              } else if (wo.filter_$externalFilters) {
                $el = wo.filter_$externalFilters.filter('[data-column="' + columnIndex + '"]');
              }
              isMatch = $el.length ? c.widgetOptions.filter_matchType[($el[0].nodeName || "").toLowerCase()] === "match" : (
                // default to exact, if no inputs found
                false
              );
            }
            return isMatch;
          },
          processRow: function(c, data, vars) {
            var result, filterMatched, fxn, ffxn, txt, wo = c.widgetOptions, showRow = true, hasAnyMatchInput = wo.filter_$anyMatch && wo.filter_$anyMatch.length, columnIndex = wo.filter_$anyMatch && wo.filter_$anyMatch.length ? (
              // look for multiple columns '1-3,4-6,8'
              tsf.multipleColumns(c, wo.filter_$anyMatch)
            ) : [];
            data.$cells = data.$row.children();
            data.matchedOn = null;
            if (data.anyMatchFlag && columnIndex.length > 1 || data.anyMatchFilter && !hasAnyMatchInput) {
              data.anyMatch = true;
              data.isMatch = true;
              data.rowArray = data.$cells.map(function(i) {
                if ($.inArray(i, columnIndex) > -1 || data.anyMatchFilter && !hasAnyMatchInput) {
                  if (data.parsed[i]) {
                    txt = data.cacheArray[i];
                  } else {
                    txt = data.rawArray[i];
                    txt = $.trim(wo.filter_ignoreCase ? txt.toLowerCase() : txt);
                    if (c.sortLocaleCompare) {
                      txt = ts.replaceAccents(txt);
                    }
                  }
                  return txt;
                }
              }).get();
              data.filter = data.anyMatchFilter;
              data.iFilter = data.iAnyMatchFilter;
              data.exact = data.rowArray.join(" ");
              data.iExact = wo.filter_ignoreCase ? data.exact.toLowerCase() : data.exact;
              data.cache = data.cacheArray.slice(0, -1).join(" ");
              vars.excludeMatch = vars.noAnyMatch;
              filterMatched = tsf.processTypes(c, data, vars);
              if (filterMatched !== null) {
                showRow = filterMatched;
              } else {
                if (wo.filter_startsWith) {
                  showRow = false;
                  columnIndex = Math.min(c.columns, data.rowArray.length);
                  while (!showRow && columnIndex > 0) {
                    columnIndex--;
                    showRow = showRow || data.rowArray[columnIndex].indexOf(data.iFilter) === 0;
                  }
                } else {
                  showRow = (data.iExact + data.childRowText).indexOf(data.iFilter) >= 0;
                }
              }
              data.anyMatch = false;
              if (data.filters.join("") === data.filter) {
                return showRow;
              }
            }
            for (columnIndex = 0; columnIndex < c.columns; columnIndex++) {
              data.filter = data.filters[columnIndex];
              data.index = columnIndex;
              vars.excludeMatch = vars.excludeFilter[columnIndex];
              if (data.filter) {
                data.cache = data.cacheArray[columnIndex];
                result = data.parsed[columnIndex] ? data.cache : data.rawArray[columnIndex] || "";
                data.exact = c.sortLocaleCompare ? ts.replaceAccents(result) : result;
                data.iExact = !tsfRegex.type.test(typeof data.exact) && wo.filter_ignoreCase ? data.exact.toLowerCase() : data.exact;
                data.isMatch = tsf.matchType(c, columnIndex);
                result = showRow;
                ffxn = wo.filter_columnFilters ? c.$filters.add(wo.filter_$externalFilters).filter('[data-column="' + columnIndex + '"]').find("select option:selected").attr("data-function-name") || "" : "";
                if (c.sortLocaleCompare) {
                  data.filter = ts.replaceAccents(data.filter);
                }
                if (wo.filter_defaultFilter && tsfRegex.iQuery.test(vars.defaultColFilter[columnIndex])) {
                  data.filter = tsf.defaultFilter(data.filter, vars.defaultColFilter[columnIndex]);
                }
                data.iFilter = wo.filter_ignoreCase ? (data.filter || "").toLowerCase() : data.filter;
                fxn = vars.functions[columnIndex];
                filterMatched = null;
                if (fxn) {
                  if (typeof fxn === "function") {
                    filterMatched = fxn(data.exact, data.cache, data.filter, columnIndex, data.$row, c, data);
                  } else if (typeof fxn[ffxn || data.filter] === "function") {
                    txt = ffxn || data.filter;
                    filterMatched = fxn[txt](data.exact, data.cache, data.filter, columnIndex, data.$row, c, data);
                  }
                }
                if (filterMatched === null) {
                  filterMatched = tsf.processTypes(c, data, vars);
                  txt = fxn === true && (data.matchedOn === "and" || data.matchedOn === "or");
                  if (filterMatched !== null && !txt) {
                    result = filterMatched;
                  } else {
                    if (fxn === true) {
                      result = data.isMatch ? (
                        // data.iExact may be a number
                        ("" + data.iExact).search(data.iFilter) >= 0
                      ) : data.filter === data.exact;
                    } else {
                      txt = (data.iExact + data.childRowText).indexOf(tsf.parseFilter(c, data.iFilter, data));
                      result = !wo.filter_startsWith && txt >= 0 || wo.filter_startsWith && txt === 0;
                    }
                  }
                } else {
                  result = filterMatched;
                }
                showRow = result ? showRow : false;
              }
            }
            return showRow;
          },
          findRows: function(table, filters, currentFilters) {
            if (tsf.equalFilters(table.config, table.config.lastSearch, currentFilters) || !table.config.widgetOptions.filter_initialized) {
              return;
            }
            var len, norm_rows, rowData, $rows, $row, rowIndex, tbodyIndex, $tbody, columnIndex, isChild, childRow, lastSearch, showRow, showParent, time, val, indx, notFiltered, searchFiltered, query, injected, res, id, txt, storedFilters = $.extend([], filters), c = table.config, wo = c.widgetOptions, debug = ts.debug(c, "filter"), data = {
              anyMatch: false,
              filters,
              // regex filter type cache
              filter_regexCache: []
            }, vars = {
              // anyMatch really screws up with these types of filters
              noAnyMatch: ["range", "operators"],
              // cache filter variables that use ts.getColumnData in the main loop
              functions: [],
              excludeFilter: [],
              defaultColFilter: [],
              defaultAnyFilter: ts.getColumnData(table, wo.filter_defaultFilter, c.columns, true) || ""
            };
            data.parsed = [];
            for (columnIndex = 0; columnIndex < c.columns; columnIndex++) {
              data.parsed[columnIndex] = wo.filter_useParsedData || // parser has a "parsed" parameter
              (c.parsers && c.parsers[columnIndex] && c.parsers[columnIndex].parsed || // getData may not return 'parsed' if other 'filter-' class names exist
              // ( e.g. <th class="filter-select filter-parsed"> )
              ts.getData && ts.getData(
                c.$headerIndexed[columnIndex],
                ts.getColumnData(table, c.headers, columnIndex),
                "filter"
              ) === "parsed" || c.$headerIndexed[columnIndex].hasClass("filter-parsed"));
              vars.functions[columnIndex] = ts.getColumnData(table, wo.filter_functions, columnIndex) || c.$headerIndexed[columnIndex].hasClass("filter-select");
              vars.defaultColFilter[columnIndex] = ts.getColumnData(table, wo.filter_defaultFilter, columnIndex) || "";
              vars.excludeFilter[columnIndex] = (ts.getColumnData(table, wo.filter_excludeFilter, columnIndex, true) || "").split(/\s+/);
            }
            if (debug) {
              console.log("Filter >> Starting filter widget search", filters);
              time = /* @__PURE__ */ new Date();
            }
            c.filteredRows = 0;
            c.totalRows = 0;
            currentFilters = storedFilters || [];
            for (tbodyIndex = 0; tbodyIndex < c.$tbodies.length; tbodyIndex++) {
              $tbody = ts.processTbody(table, c.$tbodies.eq(tbodyIndex), true);
              columnIndex = c.columns;
              norm_rows = c.cache[tbodyIndex].normalized;
              $rows = $($.map(norm_rows, function(el) {
                return el[columnIndex].$row.get();
              }));
              if (currentFilters.join("") === "" || wo.filter_serversideFiltering) {
                $rows.removeClass(wo.filter_filteredRow).not("." + c.cssChildRow).css("display", "");
              } else {
                $rows = $rows.not("." + c.cssChildRow);
                len = $rows.length;
                if (wo.filter_$anyMatch && wo.filter_$anyMatch.length || typeof filters[c.columns] !== "undefined") {
                  data.anyMatchFlag = true;
                  data.anyMatchFilter = "" + (filters[c.columns] || wo.filter_$anyMatch && tsf.getLatestSearch(wo.filter_$anyMatch).val() || "");
                  if (wo.filter_columnAnyMatch) {
                    query = data.anyMatchFilter.split(tsfRegex.andSplit);
                    injected = false;
                    for (indx = 0; indx < query.length; indx++) {
                      res = query[indx].split(":");
                      if (res.length > 1) {
                        if (isNaN(res[0])) {
                          $.each(c.headerContent, function(i, txt2) {
                            if (txt2.toLowerCase().indexOf(res[0]) > -1) {
                              id = i;
                              filters[id] = res[1];
                            }
                          });
                        } else {
                          id = parseInt(res[0], 10) - 1;
                        }
                        if (id >= 0 && id < c.columns) {
                          filters[id] = res[1];
                          query.splice(indx, 1);
                          indx--;
                          injected = true;
                        }
                      }
                    }
                    if (injected) {
                      data.anyMatchFilter = query.join(" && ");
                    }
                  }
                }
                searchFiltered = wo.filter_searchFiltered;
                lastSearch = c.lastSearch || c.$table.data("lastSearch") || [];
                if (searchFiltered) {
                  for (indx = 0; indx < columnIndex + 1; indx++) {
                    val = filters[indx] || "";
                    if (!searchFiltered) {
                      indx = columnIndex;
                    }
                    searchFiltered = searchFiltered && lastSearch.length && // there are no changes from beginning of filter
                    val.indexOf(lastSearch[indx] || "") === 0 && // if there is NOT a logical 'or', or range ( 'to' or '-' ) in the string
                    !tsfRegex.alreadyFiltered.test(val) && // if we are not doing exact matches, using '|' ( logical or ) or not '!'
                    !tsfRegex.exactTest.test(val) && // don't search only filtered if the value is negative
                    // ( '> -10' => '> -100' will ignore hidden rows )
                    !(tsfRegex.isNeg1.test(val) || tsfRegex.isNeg2.test(val)) && // if filtering using a select without a 'filter-match' class ( exact match ) - fixes #593
                    !(val !== "" && c.$filters && c.$filters.filter('[data-column="' + indx + '"]').find("select").length && !tsf.matchType(c, indx));
                  }
                }
                notFiltered = $rows.not("." + wo.filter_filteredRow).length;
                if (searchFiltered && notFiltered === 0) {
                  searchFiltered = false;
                }
                if (debug) {
                  console.log("Filter >> Searching through " + (searchFiltered && notFiltered < len ? notFiltered : "all") + " rows");
                }
                if (data.anyMatchFlag) {
                  if (c.sortLocaleCompare) {
                    data.anyMatchFilter = ts.replaceAccents(data.anyMatchFilter);
                  }
                  if (wo.filter_defaultFilter && tsfRegex.iQuery.test(vars.defaultAnyFilter)) {
                    data.anyMatchFilter = tsf.defaultFilter(data.anyMatchFilter, vars.defaultAnyFilter);
                    searchFiltered = false;
                  }
                  data.iAnyMatchFilter = !(wo.filter_ignoreCase && c.ignoreCase) ? data.anyMatchFilter : data.anyMatchFilter.toLowerCase();
                }
                for (rowIndex = 0; rowIndex < len; rowIndex++) {
                  txt = $rows[rowIndex].className;
                  isChild = rowIndex && tsfRegex.child.test(txt);
                  if (isChild || searchFiltered && tsfRegex.filtered.test(txt)) {
                    continue;
                  }
                  data.$row = $rows.eq(rowIndex);
                  data.rowIndex = rowIndex;
                  data.cacheArray = norm_rows[rowIndex];
                  rowData = data.cacheArray[c.columns];
                  data.rawArray = rowData.raw;
                  data.childRowText = "";
                  if (!wo.filter_childByColumn) {
                    txt = "";
                    childRow = rowData.child;
                    for (indx = 0; indx < childRow.length; indx++) {
                      txt += " " + childRow[indx].join(" ") || "";
                    }
                    data.childRowText = wo.filter_childRows ? wo.filter_ignoreCase ? txt.toLowerCase() : txt : "";
                  }
                  showRow = false;
                  showParent = tsf.processRow(c, data, vars);
                  $row = rowData.$row;
                  val = showParent ? true : false;
                  childRow = rowData.$row.filter(":gt(0)");
                  if (wo.filter_childRows && childRow.length) {
                    if (wo.filter_childByColumn) {
                      if (!wo.filter_childWithSibs) {
                        childRow.addClass(wo.filter_filteredRow);
                        $row = $row.eq(0);
                      }
                      for (indx = 0; indx < childRow.length; indx++) {
                        data.$row = childRow.eq(indx);
                        data.cacheArray = rowData.child[indx];
                        data.rawArray = data.cacheArray;
                        val = tsf.processRow(c, data, vars);
                        showRow = showRow || val;
                        if (!wo.filter_childWithSibs && val) {
                          childRow.eq(indx).removeClass(wo.filter_filteredRow);
                        }
                      }
                    }
                    showRow = showRow || showParent;
                  } else {
                    showRow = val;
                  }
                  $row.toggleClass(wo.filter_filteredRow, !showRow)[0].display = showRow ? "" : "none";
                }
              }
              c.filteredRows += $rows.not("." + wo.filter_filteredRow).length;
              c.totalRows += $rows.length;
              ts.processTbody(table, $tbody, false);
            }
            c.lastCombinedFilter = storedFilters.join("");
            c.lastSearch = storedFilters;
            c.$table.data("lastSearch", storedFilters);
            if (wo.filter_saveFilters && ts.storage) {
              ts.storage(table, "tablesorter-filters", tsf.processFilters(storedFilters, true));
            }
            if (debug) {
              console.log("Filter >> Completed search" + ts.benchmark(time));
            }
            if (wo.filter_initialized) {
              c.$table.triggerHandler("filterBeforeEnd", c);
              c.$table.triggerHandler("filterEnd", c);
            }
            setTimeout(function() {
              ts.applyWidget(c.table);
            }, 0);
          },
          getOptionSource: function(table, column, onlyAvail) {
            table = $(table)[0];
            var c = table.config, wo = c.widgetOptions, arry = false, source = wo.filter_selectSource, last = c.$table.data("lastSearch") || [], fxn = typeof source === "function" ? true : ts.getColumnData(table, source, column);
            if (onlyAvail && last[column] !== "") {
              onlyAvail = false;
            }
            if (fxn === true) {
              arry = source(table, column, onlyAvail);
            } else if (fxn instanceof $ || $.type(fxn) === "string" && fxn.indexOf("</option>") >= 0) {
              return fxn;
            } else if ($.isArray(fxn)) {
              arry = fxn;
            } else if ($.type(source) === "object" && fxn) {
              arry = fxn(table, column, onlyAvail);
              if (arry === null) {
                return null;
              }
            }
            if (arry === false) {
              arry = tsf.getOptions(table, column, onlyAvail);
            }
            return tsf.processOptions(table, column, arry);
          },
          processOptions: function(table, column, arry) {
            if (!$.isArray(arry)) {
              return false;
            }
            table = $(table)[0];
            var cts, txt, indx, len, parsedTxt, str, c = table.config, validColumn = typeof column !== "undefined" && column !== null && column >= 0 && column < c.columns, direction = validColumn ? c.$headerIndexed[column].hasClass("filter-select-sort-desc") : false, parsed = [];
            arry = $.grep(arry, function(value, indx2) {
              if (value.text) {
                return true;
              }
              return $.inArray(value, arry) === indx2;
            });
            if (validColumn && c.$headerIndexed[column].hasClass("filter-select-nosort")) {
              return arry;
            } else {
              len = arry.length;
              for (indx = 0; indx < len; indx++) {
                txt = arry[indx];
                str = txt.text ? txt.text : txt;
                parsedTxt = (validColumn && c.parsers && c.parsers.length && c.parsers[column].format(str, table, [], column) || str).toString();
                parsedTxt = c.widgetOptions.filter_ignoreCase ? parsedTxt.toLowerCase() : parsedTxt;
                if (txt.text) {
                  txt.parsed = parsedTxt;
                  parsed[parsed.length] = txt;
                } else {
                  parsed[parsed.length] = {
                    text: txt,
                    // check parser length - fixes #934
                    parsed: parsedTxt
                  };
                }
              }
              cts = c.textSorter || "";
              parsed.sort(function(a, b) {
                var x = direction ? b.parsed : a.parsed, y = direction ? a.parsed : b.parsed;
                if (validColumn && typeof cts === "function") {
                  return cts(x, y, true, column, table);
                } else if (validColumn && typeof cts === "object" && cts.hasOwnProperty(column)) {
                  return cts[column](x, y, true, column, table);
                } else if (ts.sortNatural) {
                  return ts.sortNatural(x, y);
                }
                return true;
              });
              arry = [];
              len = parsed.length;
              for (indx = 0; indx < len; indx++) {
                arry[arry.length] = parsed[indx];
              }
              return arry;
            }
          },
          getOptions: function(table, column, onlyAvail) {
            table = $(table)[0];
            var rowIndex, tbodyIndex, len, row, cache, indx, child, childLen, c = table.config, wo = c.widgetOptions, arry = [];
            for (tbodyIndex = 0; tbodyIndex < c.$tbodies.length; tbodyIndex++) {
              cache = c.cache[tbodyIndex];
              len = c.cache[tbodyIndex].normalized.length;
              for (rowIndex = 0; rowIndex < len; rowIndex++) {
                row = cache.row ? cache.row[rowIndex] : cache.normalized[rowIndex][c.columns].$row[0];
                if (onlyAvail && row.className.match(wo.filter_filteredRow)) {
                  continue;
                }
                if (wo.filter_useParsedData || c.parsers[column].parsed || c.$headerIndexed[column].hasClass("filter-parsed")) {
                  arry[arry.length] = "" + cache.normalized[rowIndex][column];
                  if (wo.filter_childRows && wo.filter_childByColumn) {
                    childLen = cache.normalized[rowIndex][c.columns].$row.length - 1;
                    for (indx = 0; indx < childLen; indx++) {
                      arry[arry.length] = "" + cache.normalized[rowIndex][c.columns].child[indx][column];
                    }
                  }
                } else {
                  arry[arry.length] = cache.normalized[rowIndex][c.columns].raw[column];
                  if (wo.filter_childRows && wo.filter_childByColumn) {
                    childLen = cache.normalized[rowIndex][c.columns].$row.length;
                    for (indx = 1; indx < childLen; indx++) {
                      child = cache.normalized[rowIndex][c.columns].$row.eq(indx).children().eq(column);
                      arry[arry.length] = "" + ts.getElementText(c, child, column);
                    }
                  }
                }
              }
            }
            return arry;
          },
          buildSelect: function(table, column, arry, updating, onlyAvail) {
            table = $(table)[0];
            column = parseInt(column, 10);
            if (!table.config.cache || $.isEmptyObject(table.config.cache)) {
              return;
            }
            var indx, val, txt, t, $filters, $filter, option, c = table.config, wo = c.widgetOptions, node = c.$headerIndexed[column], options = '<option value="">' + (node.data("placeholder") || node.attr("data-placeholder") || wo.filter_placeholder.select || "") + "</option>", currentValue = c.$table.find("thead").find("select." + tscss.filter + '[data-column="' + column + '"]').val();
            if (typeof arry === "undefined" || arry === "") {
              arry = tsf.getOptionSource(table, column, onlyAvail);
              if (arry === null) {
                return;
              }
            }
            if ($.isArray(arry)) {
              for (indx = 0; indx < arry.length; indx++) {
                option = arry[indx];
                if (option.text) {
                  option["data-function-name"] = typeof option.value === "undefined" ? option.text : option.value;
                  options += "<option";
                  for (val in option) {
                    if (option.hasOwnProperty(val) && val !== "text") {
                      options += " " + val + '="' + option[val].replace(tsfRegex.quote, "&quot;") + '"';
                    }
                  }
                  if (!option.value) {
                    options += ' value="' + option.text.replace(tsfRegex.quote, "&quot;") + '"';
                  }
                  options += ">" + option.text.replace(tsfRegex.quote, "&quot;") + "</option>";
                } else if ("" + option !== "[object Object]") {
                  txt = option = ("" + option).replace(tsfRegex.quote, "&quot;");
                  val = txt;
                  if (txt.indexOf(wo.filter_selectSourceSeparator) >= 0) {
                    t = txt.split(wo.filter_selectSourceSeparator);
                    val = t[0];
                    txt = t[1];
                  }
                  options += option !== "" ? "<option " + (val === txt ? "" : 'data-function-name="' + option + '" ') + 'value="' + val + '">' + txt + "</option>" : "";
                }
              }
              arry = [];
            }
            $filters = (c.$filters ? c.$filters : c.$table.children("thead")).find("." + tscss.filter);
            if (wo.filter_$externalFilters) {
              $filters = $filters && $filters.length ? $filters.add(wo.filter_$externalFilters) : wo.filter_$externalFilters;
            }
            $filter = $filters.filter('select[data-column="' + column + '"]');
            if ($filter.length) {
              $filter[updating ? "html" : "append"](options);
              if (!$.isArray(arry)) {
                $filter.append(arry).val(currentValue);
              }
              $filter.val(currentValue);
            }
          },
          buildDefault: function(table, updating) {
            var columnIndex, $header, noSelect, c = table.config, wo = c.widgetOptions, columns = c.columns;
            for (columnIndex = 0; columnIndex < columns; columnIndex++) {
              $header = c.$headerIndexed[columnIndex];
              noSelect = !($header.hasClass("filter-false") || $header.hasClass("parser-false"));
              if (($header.hasClass("filter-select") || ts.getColumnData(table, wo.filter_functions, columnIndex) === true) && noSelect) {
                tsf.buildSelect(table, columnIndex, "", updating, $header.hasClass(wo.filter_onlyAvail));
              }
            }
          }
        };
        tsfRegex = tsf.regex;
        ts.getFilters = function(table, getRaw, setFilters, skipFirst) {
          var i, $filters, $column, cols, filters = [], c = table ? $(table)[0].config : "", wo = c ? c.widgetOptions : "";
          if (getRaw !== true && wo && !wo.filter_columnFilters || // setFilters called, but last search is exactly the same as the current
          // fixes issue #733 & #903 where calling update causes the input values to reset
          $.isArray(setFilters) && tsf.equalFilters(c, setFilters, c.lastSearch)) {
            return $(table).data("lastSearch") || [];
          }
          if (c) {
            if (c.$filters) {
              $filters = c.$filters.find("." + tscss.filter);
            }
            if (wo.filter_$externalFilters) {
              $filters = $filters && $filters.length ? $filters.add(wo.filter_$externalFilters) : wo.filter_$externalFilters;
            }
            if ($filters && $filters.length) {
              filters = setFilters || [];
              for (i = 0; i < c.columns + 1; i++) {
                cols = i === c.columns ? (
                  // 'all' columns can now include a range or set of columms ( data-column='0-2,4,6-7' )
                  wo.filter_anyColumnSelector + "," + wo.filter_multipleColumnSelector
                ) : '[data-column="' + i + '"]';
                $column = $filters.filter(cols);
                if ($column.length) {
                  $column = tsf.getLatestSearch($column);
                  if ($.isArray(setFilters)) {
                    if (skipFirst && $column.length > 1) {
                      $column = $column.slice(1);
                    }
                    if (i === c.columns) {
                      cols = $column.filter(wo.filter_anyColumnSelector);
                      $column = cols.length ? cols : $column;
                    }
                    $column.val(setFilters[i]).trigger("change" + c.namespace);
                  } else {
                    filters[i] = $column.val() || "";
                    if (i === c.columns) {
                      $column.slice(1).filter('[data-column*="' + $column.attr("data-column") + '"]').val(filters[i]);
                    } else {
                      $column.slice(1).val(filters[i]);
                    }
                  }
                  if (i === c.columns && $column.length) {
                    wo.filter_$anyMatch = $column;
                  }
                }
              }
            }
          }
          return filters;
        };
        ts.setFilters = function(table, filter, apply, skipFirst) {
          var c = table ? $(table)[0].config : "", valid = ts.getFilters(table, true, filter, skipFirst);
          if (typeof apply === "undefined") {
            apply = true;
          }
          if (c && apply) {
            c.lastCombinedFilter = null;
            c.lastSearch = [];
            tsf.searching(c.table, filter, skipFirst);
            c.$table.triggerHandler("filterFomatterUpdate");
          }
          return valid.length !== 0;
        };
      })(jQuery2);
      ;
      (function($, window2) {
        "use strict";
        var ts = $.tablesorter || {};
        $.extend(ts.css, {
          sticky: "tablesorter-stickyHeader",
          // stickyHeader
          stickyVis: "tablesorter-sticky-visible",
          stickyHide: "tablesorter-sticky-hidden",
          stickyWrap: "tablesorter-sticky-wrapper"
        });
        ts.addHeaderResizeEvent = function(table, disable, settings) {
          table = $(table)[0];
          if (!table.config) {
            return;
          }
          var defaults = {
            timer: 250
          }, options = $.extend({}, defaults, settings), c = table.config, wo = c.widgetOptions, checkSizes = function(triggerEvent) {
            var index, headers, $header, sizes, width, height, len = c.$headers.length;
            wo.resize_flag = true;
            headers = [];
            for (index = 0; index < len; index++) {
              $header = c.$headers.eq(index);
              sizes = $header.data("savedSizes") || [0, 0];
              width = $header[0].offsetWidth;
              height = $header[0].offsetHeight;
              if (width !== sizes[0] || height !== sizes[1]) {
                $header.data("savedSizes", [width, height]);
                headers.push($header[0]);
              }
            }
            if (headers.length && triggerEvent !== false) {
              c.$table.triggerHandler("resize", [headers]);
            }
            wo.resize_flag = false;
          };
          clearInterval(wo.resize_timer);
          if (disable) {
            wo.resize_flag = false;
            return false;
          }
          checkSizes(false);
          wo.resize_timer = setInterval(function() {
            if (wo.resize_flag) {
              return;
            }
            checkSizes();
          }, options.timer);
        };
        function getStickyOffset(c, wo) {
          var $el = isNaN(wo.stickyHeaders_offset) ? $(wo.stickyHeaders_offset) : [];
          return $el.length ? $el.height() || 0 : parseInt(wo.stickyHeaders_offset, 10) || 0;
        }
        ts.addWidget({
          id: "stickyHeaders",
          priority: 54,
          // sticky widget must be initialized after the filter & before pager widget!
          options: {
            stickyHeaders: "",
            // extra class name added to the sticky header row
            stickyHeaders_appendTo: null,
            // jQuery selector or object to phycially attach the sticky headers
            stickyHeaders_attachTo: null,
            // jQuery selector or object to attach scroll listener to (overridden by xScroll & yScroll settings)
            stickyHeaders_xScroll: null,
            // jQuery selector or object to monitor horizontal scroll position (defaults: xScroll > attachTo > window)
            stickyHeaders_yScroll: null,
            // jQuery selector or object to monitor vertical scroll position (defaults: yScroll > attachTo > window)
            stickyHeaders_offset: 0,
            // number or jquery selector targeting the position:fixed element
            stickyHeaders_filteredToTop: true,
            // scroll table top into view after filtering
            stickyHeaders_cloneId: "-sticky",
            // added to table ID, if it exists
            stickyHeaders_addResizeEvent: true,
            // trigger 'resize' event on headers
            stickyHeaders_includeCaption: true,
            // if false and a caption exist, it won't be included in the sticky header
            stickyHeaders_zIndex: 2
            // The zIndex of the stickyHeaders, allows the user to adjust this to their needs
          },
          format: function(table, c, wo) {
            if (c.$table.hasClass("hasStickyHeaders") || $.inArray("filter", c.widgets) >= 0 && !c.$table.hasClass("hasFilters")) {
              return;
            }
            var index, len, $t, $table = c.$table, $attach = $(wo.stickyHeaders_attachTo || wo.stickyHeaders_appendTo), namespace = c.namespace + "stickyheaders ", $yScroll = $(wo.stickyHeaders_yScroll || wo.stickyHeaders_attachTo || window2), $xScroll = $(wo.stickyHeaders_xScroll || wo.stickyHeaders_attachTo || window2), $thead = $table.children("thead:first"), $header = $thead.children("tr").not(".sticky-false").children(), $tfoot = $table.children("tfoot"), stickyOffset = getStickyOffset(c, wo), $nestedSticky = $table.parent().closest("." + ts.css.table).hasClass("hasStickyHeaders") ? $table.parent().closest("table.tablesorter")[0].config.widgetOptions.$sticky.parent() : [], nestedStickyTop = $nestedSticky.length ? $nestedSticky.height() : 0, $stickyTable = wo.$sticky = $table.clone().addClass("containsStickyHeaders " + ts.css.sticky + " " + wo.stickyHeaders + " " + c.namespace.slice(1) + "_extra_table").wrap('<div class="' + ts.css.stickyWrap + '">'), $stickyWrap = $stickyTable.parent().addClass(ts.css.stickyHide).css({
              position: $attach.length ? "absolute" : "fixed",
              padding: parseInt($stickyTable.parent().parent().css("padding-left"), 10),
              top: stickyOffset + nestedStickyTop,
              left: 0,
              visibility: "hidden",
              zIndex: wo.stickyHeaders_zIndex || 2
            }), $stickyThead = $stickyTable.children("thead:first"), $stickyCells, laststate = "", setWidth = function($orig, $clone) {
              var index2, width, border, $cell, $this, $cells = $orig.filter(":visible"), len2 = $cells.length;
              for (index2 = 0; index2 < len2; index2++) {
                $cell = $clone.filter(":visible").eq(index2);
                $this = $cells.eq(index2);
                if ($this.css("box-sizing") === "border-box") {
                  width = $this.outerWidth();
                } else {
                  if ($cell.css("border-collapse") === "collapse") {
                    if (window2.getComputedStyle) {
                      width = parseFloat(window2.getComputedStyle($this[0], null).width);
                    } else {
                      border = parseFloat($this.css("border-width"));
                      width = $this.outerWidth() - parseFloat($this.css("padding-left")) - parseFloat($this.css("padding-right")) - border;
                    }
                  } else {
                    width = $this.width();
                  }
                }
                $cell.css({
                  "width": width,
                  "min-width": width,
                  "max-width": width
                });
              }
            }, getLeftPosition = function(yWindow) {
              if (yWindow === false && $nestedSticky.length) {
                return $table.position().left;
              }
              return $attach.length ? parseInt($attach.css("padding-left"), 10) || 0 : $table.offset().left - parseInt($table.css("margin-left"), 10) - $(window2).scrollLeft();
            }, resizeHeader = function() {
              $stickyWrap.css({
                left: getLeftPosition(),
                width: $table.outerWidth()
              });
              setWidth($table, $stickyTable);
              setWidth($header, $stickyCells);
            }, scrollSticky = function(resizing) {
              if (!$table.is(":visible")) {
                return;
              }
              nestedStickyTop = $nestedSticky.length ? $nestedSticky.offset().top - $yScroll.scrollTop() + $nestedSticky.height() : 0;
              var tmp, offset = $table.offset(), stickyOffset2 = getStickyOffset(c, wo), yWindow = $.isWindow($yScroll[0]), yScroll = yWindow ? $yScroll.scrollTop() : (
                // use parent sticky position if nested AND inside of a scrollable element - see #1512
                $nestedSticky.length ? parseInt($nestedSticky[0].style.top, 10) : $yScroll.offset().top
              ), attachTop = $attach.length ? yScroll : $yScroll.scrollTop(), captionHeight = wo.stickyHeaders_includeCaption ? 0 : $table.children("caption").height() || 0, scrollTop = attachTop + stickyOffset2 + nestedStickyTop - captionHeight, tableHeight = $table.height() - ($stickyWrap.height() + ($tfoot.height() || 0)) - captionHeight, isVisible = scrollTop > offset.top && scrollTop < offset.top + tableHeight ? "visible" : "hidden", state = isVisible === "visible" ? ts.css.stickyVis : ts.css.stickyHide, needsUpdating = !$stickyWrap.hasClass(state), cssSettings = { visibility: isVisible };
              if ($attach.length) {
                needsUpdating = true;
                cssSettings.top = yWindow ? scrollTop - $attach.offset().top : $attach.scrollTop();
              }
              tmp = getLeftPosition(yWindow);
              if (tmp !== parseInt($stickyWrap.css("left"), 10)) {
                needsUpdating = true;
                cssSettings.left = tmp;
              }
              cssSettings.top = (cssSettings.top || 0) + // If nested AND inside of a scrollable element, only add parent sticky height
              (!yWindow && $nestedSticky.length ? $nestedSticky.height() : stickyOffset2 + nestedStickyTop);
              if (needsUpdating) {
                $stickyWrap.removeClass(ts.css.stickyVis + " " + ts.css.stickyHide).addClass(state).css(cssSettings);
              }
              if (isVisible !== laststate || resizing) {
                resizeHeader();
                laststate = isVisible;
              }
            };
            if ($attach.length && !$attach.css("position")) {
              $attach.css("position", "relative");
            }
            if ($stickyTable.attr("id")) {
              $stickyTable[0].id += wo.stickyHeaders_cloneId;
            }
            $stickyTable.find("> thead:gt(0), tr.sticky-false").hide();
            $stickyTable.find("> tbody, > tfoot").remove();
            $stickyTable.find("caption").toggle(wo.stickyHeaders_includeCaption);
            $stickyCells = $stickyThead.children().children();
            $stickyTable.css({ height: 0, width: 0, margin: 0 });
            $stickyCells.find("." + ts.css.resizer).remove();
            $table.addClass("hasStickyHeaders").bind("pagerComplete" + namespace, function() {
              resizeHeader();
            });
            ts.bindEvents(table, $stickyThead.children().children("." + ts.css.header));
            if (wo.stickyHeaders_appendTo) {
              $(wo.stickyHeaders_appendTo).append($stickyWrap);
            } else {
              $table.after($stickyWrap);
            }
            if (c.onRenderHeader) {
              $t = $stickyThead.children("tr").children();
              len = $t.length;
              for (index = 0; index < len; index++) {
                c.onRenderHeader.apply($t.eq(index), [index, c, $stickyTable]);
              }
            }
            $xScroll.add($yScroll).unbind("scroll resize ".split(" ").join(namespace).replace(/\s+/g, " ")).bind("scroll resize ".split(" ").join(namespace), function(event) {
              scrollSticky(event.type === "resize");
            });
            c.$table.unbind("stickyHeadersUpdate" + namespace).bind("stickyHeadersUpdate" + namespace, function() {
              scrollSticky(true);
            });
            if (wo.stickyHeaders_addResizeEvent) {
              ts.addHeaderResizeEvent(table);
            }
            if ($table.hasClass("hasFilters") && wo.filter_columnFilters) {
              $table.bind("filterEnd" + namespace, function() {
                var $td = $(document.activeElement).closest("td"), column = $td.parent().children().index($td);
                if ($stickyWrap.hasClass(ts.css.stickyVis) && wo.stickyHeaders_filteredToTop) {
                  window2.scrollTo(0, $table.position().top);
                  if (column >= 0 && c.$filters) {
                    c.$filters.eq(column).find("a, select, input").filter(":visible").focus();
                  }
                }
              });
              ts.filter.bindSearch($table, $stickyCells.find("." + ts.css.filter));
              if (wo.filter_hideFilters) {
                ts.filter.hideFilters(c, $stickyTable);
              }
            }
            if (wo.stickyHeaders_addResizeEvent) {
              $table.bind("resize" + c.namespace + "stickyheaders", function() {
                resizeHeader();
              });
            }
            scrollSticky(true);
            $table.triggerHandler("stickyHeadersInit");
          },
          remove: function(table, c, wo) {
            var namespace = c.namespace + "stickyheaders ";
            c.$table.removeClass("hasStickyHeaders").unbind("pagerComplete resize filterEnd stickyHeadersUpdate ".split(" ").join(namespace).replace(/\s+/g, " ")).next("." + ts.css.stickyWrap).remove();
            if (wo.$sticky && wo.$sticky.length) {
              wo.$sticky.remove();
            }
            $(window2).add(wo.stickyHeaders_xScroll).add(wo.stickyHeaders_yScroll).add(wo.stickyHeaders_attachTo).unbind("scroll resize ".split(" ").join(namespace).replace(/\s+/g, " "));
            ts.addHeaderResizeEvent(table, true);
          }
        });
      })(jQuery2, window);
      ;
      (function($, window2) {
        "use strict";
        var ts = $.tablesorter || {};
        $.extend(ts.css, {
          resizableContainer: "tablesorter-resizable-container",
          resizableHandle: "tablesorter-resizable-handle",
          resizableNoSelect: "tablesorter-disableSelection",
          resizableStorage: "tablesorter-resizable"
        });
        $(function() {
          var s = "<style>body." + ts.css.resizableNoSelect + " { -ms-user-select: none; -moz-user-select: -moz-none;-khtml-user-select: none; -webkit-user-select: none; user-select: none; }." + ts.css.resizableContainer + " { position: relative; height: 1px; }." + ts.css.resizableHandle + " { position: absolute; display: inline-block; width: 8px;top: 1px; cursor: ew-resize; z-index: 3; user-select: none; -moz-user-select: none; }</style>";
          $("head").append(s);
        });
        ts.resizable = {
          init: function(c, wo) {
            if (c.$table.hasClass("hasResizable")) {
              return;
            }
            c.$table.addClass("hasResizable");
            var noResize, $header, column, storedSizes, tmp, $table = c.$table, $parent = $table.parent(), marginTop = parseInt($table.css("margin-top"), 10), vars = wo.resizable_vars = {
              useStorage: ts.storage && wo.resizable !== false,
              $wrap: $parent,
              mouseXPosition: 0,
              $target: null,
              $next: null,
              overflow: $parent.css("overflow") === "auto" || $parent.css("overflow") === "scroll" || $parent.css("overflow-x") === "auto" || $parent.css("overflow-x") === "scroll",
              storedSizes: []
            };
            ts.resizableReset(c.table, true);
            vars.tableWidth = $table.width();
            vars.fullWidth = Math.abs($parent.width() - vars.tableWidth) < 20;
            if (vars.useStorage && vars.overflow) {
              ts.storage(c.table, "tablesorter-table-original-css-width", vars.tableWidth);
              tmp = ts.storage(c.table, "tablesorter-table-resized-width") || "auto";
              ts.resizable.setWidth($table, tmp, true);
            }
            wo.resizable_vars.storedSizes = storedSizes = (vars.useStorage ? ts.storage(c.table, ts.css.resizableStorage) : []) || [];
            ts.resizable.setWidths(c, wo, storedSizes);
            ts.resizable.updateStoredSizes(c, wo);
            wo.$resizable_container = $('<div class="' + ts.css.resizableContainer + '">').css({ top: marginTop }).insertBefore($table);
            for (column = 0; column < c.columns; column++) {
              $header = c.$headerIndexed[column];
              tmp = ts.getColumnData(c.table, c.headers, column);
              noResize = ts.getData($header, tmp, "resizable") === "false";
              if (!noResize) {
                $('<div class="' + ts.css.resizableHandle + '">').appendTo(wo.$resizable_container).attr({
                  "data-column": column,
                  "unselectable": "on"
                }).data("header", $header).bind("selectstart", false);
              }
            }
            ts.resizable.bindings(c, wo);
          },
          updateStoredSizes: function(c, wo) {
            var column, $header, len = c.columns, vars = wo.resizable_vars;
            vars.storedSizes = [];
            for (column = 0; column < len; column++) {
              $header = c.$headerIndexed[column];
              vars.storedSizes[column] = $header.is(":visible") ? $header.width() : 0;
            }
          },
          setWidth: function($el, width, overflow) {
            $el.css({
              "width": width,
              "min-width": overflow ? width : "",
              "max-width": overflow ? width : ""
            });
          },
          setWidths: function(c, wo, storedSizes) {
            var column, $temp, vars = wo.resizable_vars, $extra = $(c.namespace + "_extra_headers"), $col = c.$table.children("colgroup").children("col");
            storedSizes = storedSizes || vars.storedSizes || [];
            if (storedSizes.length) {
              for (column = 0; column < c.columns; column++) {
                ts.resizable.setWidth(c.$headerIndexed[column], storedSizes[column], vars.overflow);
                if ($extra.length) {
                  $temp = $extra.eq(column).add($col.eq(column));
                  ts.resizable.setWidth($temp, storedSizes[column], vars.overflow);
                }
              }
              $temp = $(c.namespace + "_extra_table");
              if ($temp.length && !ts.hasWidget(c.table, "scroller")) {
                ts.resizable.setWidth($temp, c.$table.outerWidth(), vars.overflow);
              }
            }
          },
          setHandlePosition: function(c, wo) {
            var startPosition, tableHeight = c.$table.height(), $handles = wo.$resizable_container.children(), handleCenter = Math.floor($handles.width() / 2);
            if (ts.hasWidget(c.table, "scroller")) {
              tableHeight = 0;
              c.$table.closest("." + ts.css.scrollerWrap).children().each(function() {
                var $this = $(this);
                tableHeight += $this.filter('[style*="height"]').length ? $this.height() : $this.children("table").height();
              });
            }
            if (!wo.resizable_includeFooter && c.$table.children("tfoot").length) {
              tableHeight -= c.$table.children("tfoot").height();
            }
            startPosition = parseFloat($.fn.jquery) >= 3.3 ? 0 : c.$table.position().left;
            $handles.each(function() {
              var $this = $(this), column = parseInt($this.attr("data-column"), 10), columns = c.columns - 1, $header = $this.data("header");
              if (!$header) {
                return;
              }
              if (!$header.is(":visible") || !wo.resizable_addLastColumn && ts.resizable.checkVisibleColumns(c, column)) {
                $this.hide();
              } else if (column < columns || column === columns && wo.resizable_addLastColumn) {
                $this.css({
                  display: "inline-block",
                  height: tableHeight,
                  left: $header.position().left - startPosition + $header.outerWidth() - handleCenter
                });
              }
            });
          },
          // Fixes #1485
          checkVisibleColumns: function(c, column) {
            var i, len = 0;
            for (i = column + 1; i < c.columns; i++) {
              len += c.$headerIndexed[i].is(":visible") ? 1 : 0;
            }
            return len === 0;
          },
          // prevent text selection while dragging resize bar
          toggleTextSelection: function(c, wo, toggle) {
            var namespace = c.namespace + "tsresize";
            wo.resizable_vars.disabled = toggle;
            $("body").toggleClass(ts.css.resizableNoSelect, toggle);
            if (toggle) {
              $("body").attr("unselectable", "on").bind("selectstart" + namespace, false);
            } else {
              $("body").removeAttr("unselectable").unbind("selectstart" + namespace);
            }
          },
          bindings: function(c, wo) {
            var namespace = c.namespace + "tsresize";
            wo.$resizable_container.children().bind("mousedown", function(event) {
              var column, vars = wo.resizable_vars, $extras = $(c.namespace + "_extra_headers"), $header = $(event.target).data("header");
              column = parseInt($header.attr("data-column"), 10);
              vars.$target = $header = $header.add($extras.filter('[data-column="' + column + '"]'));
              vars.target = column;
              vars.$next = event.shiftKey || wo.resizable_targetLast ? $header.parent().children().not(".resizable-false").filter(":last") : $header.nextAll(":not(.resizable-false)").eq(0);
              column = parseInt(vars.$next.attr("data-column"), 10);
              vars.$next = vars.$next.add($extras.filter('[data-column="' + column + '"]'));
              vars.next = column;
              vars.mouseXPosition = event.pageX;
              ts.resizable.updateStoredSizes(c, wo);
              ts.resizable.toggleTextSelection(c, wo, true);
            });
            $(document).bind("mousemove" + namespace, function(event) {
              var vars = wo.resizable_vars;
              if (!vars.disabled || vars.mouseXPosition === 0 || !vars.$target) {
                return;
              }
              if (wo.resizable_throttle) {
                clearTimeout(vars.timer);
                vars.timer = setTimeout(function() {
                  ts.resizable.mouseMove(c, wo, event);
                }, isNaN(wo.resizable_throttle) ? 5 : wo.resizable_throttle);
              } else {
                ts.resizable.mouseMove(c, wo, event);
              }
            }).bind("mouseup" + namespace, function() {
              if (!wo.resizable_vars.disabled) {
                return;
              }
              ts.resizable.toggleTextSelection(c, wo, false);
              ts.resizable.stopResize(c, wo);
              ts.resizable.setHandlePosition(c, wo);
            });
            $(window2).bind("resize" + namespace + " resizeEnd" + namespace, function() {
              ts.resizable.setHandlePosition(c, wo);
            });
            c.$table.bind("columnUpdate pagerComplete resizableUpdate ".split(" ").join(namespace + " "), function() {
              ts.resizable.setHandlePosition(c, wo);
            }).bind("resizableReset" + namespace, function() {
              ts.resizableReset(c.table);
            }).find("thead:first").add($(c.namespace + "_extra_table").find("thead:first")).bind("contextmenu" + namespace, function() {
              var allowClick = wo.resizable_vars.storedSizes.length === 0;
              ts.resizableReset(c.table);
              ts.resizable.setHandlePosition(c, wo);
              wo.resizable_vars.storedSizes = [];
              return allowClick;
            });
          },
          mouseMove: function(c, wo, event) {
            if (wo.resizable_vars.mouseXPosition === 0 || !wo.resizable_vars.$target) {
              return;
            }
            var column, total = 0, vars = wo.resizable_vars, $next = vars.$next, tar = vars.storedSizes[vars.target], leftEdge = event.pageX - vars.mouseXPosition;
            if (vars.overflow) {
              if (tar + leftEdge > 0) {
                vars.storedSizes[vars.target] += leftEdge;
                ts.resizable.setWidth(vars.$target, vars.storedSizes[vars.target], true);
                for (column = 0; column < c.columns; column++) {
                  total += vars.storedSizes[column];
                }
                ts.resizable.setWidth(c.$table.add($(c.namespace + "_extra_table")), total);
              }
              if (!$next.length) {
                vars.$wrap[0].scrollLeft = c.$table.width();
              }
            } else if (vars.fullWidth) {
              vars.storedSizes[vars.target] += leftEdge;
              vars.storedSizes[vars.next] -= leftEdge;
              ts.resizable.setWidths(c, wo);
            } else {
              vars.storedSizes[vars.target] += leftEdge;
              ts.resizable.setWidths(c, wo);
            }
            vars.mouseXPosition = event.pageX;
            c.$table.triggerHandler("stickyHeadersUpdate");
          },
          stopResize: function(c, wo) {
            var vars = wo.resizable_vars;
            ts.resizable.updateStoredSizes(c, wo);
            if (vars.useStorage) {
              ts.storage(c.table, ts.css.resizableStorage, vars.storedSizes);
              ts.storage(c.table, "tablesorter-table-resized-width", c.$table.width());
            }
            vars.mouseXPosition = 0;
            vars.$target = vars.$next = null;
            c.$table.triggerHandler("stickyHeadersUpdate");
            c.$table.triggerHandler("resizableComplete");
          }
        };
        ts.addWidget({
          id: "resizable",
          priority: 40,
          options: {
            resizable: true,
            // save column widths to storage
            resizable_addLastColumn: false,
            resizable_includeFooter: true,
            resizable_widths: [],
            resizable_throttle: false,
            // set to true (5ms) or any number 0-10 range
            resizable_targetLast: false
          },
          init: function(table, thisWidget, c, wo) {
            ts.resizable.init(c, wo);
          },
          format: function(table, c, wo) {
            ts.resizable.setHandlePosition(c, wo);
          },
          remove: function(table, c, wo, refreshing) {
            if (wo.$resizable_container) {
              var namespace = c.namespace + "tsresize";
              c.$table.add($(c.namespace + "_extra_table")).removeClass("hasResizable").children("thead").unbind("contextmenu" + namespace);
              wo.$resizable_container.remove();
              ts.resizable.toggleTextSelection(c, wo, false);
              ts.resizableReset(table, refreshing);
              $(document).unbind("mousemove" + namespace + " mouseup" + namespace);
            }
          }
        });
        ts.resizableReset = function(table, refreshing) {
          $(table).each(function() {
            var index, $t, c = this.config, wo = c && c.widgetOptions, vars = wo.resizable_vars;
            if (table && c && c.$headerIndexed.length) {
              if (vars.overflow && vars.tableWidth) {
                ts.resizable.setWidth(c.$table, vars.tableWidth, true);
                if (vars.useStorage) {
                  ts.storage(table, "tablesorter-table-resized-width", vars.tableWidth);
                }
              }
              for (index = 0; index < c.columns; index++) {
                $t = c.$headerIndexed[index];
                if (wo.resizable_widths && wo.resizable_widths[index]) {
                  ts.resizable.setWidth($t, wo.resizable_widths[index], vars.overflow);
                } else if (!$t.hasClass("resizable-false")) {
                  ts.resizable.setWidth($t, "", vars.overflow);
                }
              }
              c.$table.triggerHandler("stickyHeadersUpdate");
              if (ts.storage && !refreshing) {
                ts.storage(this, ts.css.resizableStorage, []);
              }
            }
          });
        };
      })(jQuery2, window);
      ;
      (function($) {
        "use strict";
        var ts = $.tablesorter || {};
        function getStoredSortList(c) {
          var stored = ts.storage(c.table, "tablesorter-savesort");
          return stored && stored.hasOwnProperty("sortList") && $.isArray(stored.sortList) ? stored.sortList : [];
        }
        function sortListChanged(c, sortList) {
          return (sortList || getStoredSortList(c)).join(",") !== c.sortList.join(",");
        }
        ts.addWidget({
          id: "saveSort",
          priority: 20,
          options: {
            saveSort: true
          },
          init: function(table, thisWidget, c, wo) {
            thisWidget.format(table, c, wo, true);
          },
          format: function(table, c, wo, init) {
            var time, $table = c.$table, saveSort = wo.saveSort !== false, sortList = { "sortList": c.sortList }, debug = ts.debug(c, "saveSort");
            if (debug) {
              time = /* @__PURE__ */ new Date();
            }
            if ($table.hasClass("hasSaveSort")) {
              if (saveSort && table.hasInitialized && ts.storage && sortListChanged(c)) {
                ts.storage(table, "tablesorter-savesort", sortList);
                if (debug) {
                  console.log("saveSort >> Saving last sort: " + c.sortList + ts.benchmark(time));
                }
              }
            } else {
              $table.addClass("hasSaveSort");
              sortList = "";
              if (ts.storage) {
                sortList = getStoredSortList(c);
                if (debug) {
                  console.log('saveSort >> Last sort loaded: "' + sortList + '"' + ts.benchmark(time));
                }
                $table.bind("saveSortReset", function(event) {
                  event.stopPropagation();
                  ts.storage(table, "tablesorter-savesort", "");
                });
              }
              if (init && sortList && sortList.length > 0) {
                c.sortList = sortList;
              } else if (table.hasInitialized && sortList && sortList.length > 0) {
                if (sortListChanged(c, sortList)) {
                  ts.sortOn(c, sortList);
                }
              }
            }
          },
          remove: function(table, c) {
            c.$table.removeClass("hasSaveSort");
            if (ts.storage) {
              ts.storage(table, "tablesorter-savesort", "");
            }
          }
        });
      })(jQuery2);
      return jQuery2.tablesorter;
    });
  }
});
export default require_jquery_tablesorter_combined();
/*! Bundled license information:

tablesorter/dist/js/jquery.tablesorter.combined.js:
  (*! tablesorter (FORK) - updated 2020-03-03 (v2.31.3)*)
  (*! TableSorter (FORK) v2.31.3 *)
  (*! Widget: storage - updated 2018-03-18 (v2.30.0) *)
  (*! Widget: uitheme - updated 2018-03-18 (v2.30.0) *)
  (*! Widget: columns - updated 5/24/2017 (v2.28.11) *)
  (*! Widget: filter - updated 2018-03-18 (v2.30.0) *)
  (*! Widget: stickyHeaders - updated 9/27/2017 (v2.29.0) *)
  (*! Widget: resizable - updated 2018-03-26 (v2.30.2) *)
  (*! Widget: saveSort - updated 2018-03-19 (v2.30.1) *)
*/
//# sourceMappingURL=tablesorter.js.map
